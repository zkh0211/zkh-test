'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Is Mac?
 *
 * @type {Boolean}
 */

var IS_MAC = typeof window != 'undefined' && window.navigator && window.navigator.platform && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);

/**
 * Convenience aliases.
 *
 * @type {Object}
 */

var CONVENIENCE = {
  cmd: 'meta',
  command: 'meta',
  ctl: 'control',
  ctrl: 'control',
  del: 'delete',
  down: 'arrowdown',
  esc: 'escape',
  ins: 'insert',
  left: 'arrowleft',
  opt: 'alt',
  option: 'alt',
  return: 'enter',
  right: 'arrowright',
  space: ' ',
  spacebar: ' ',
  up: 'arrowup',
  win: 'meta',
  windows: 'meta',
  // The icon equivalents, for people who get weird.
  '↩': 'enter',
  '⇧': 'shift',
  '⌃': 'control',
  '⌘': 'meta',
  '⌥': 'alt',
  // Since `+` is used as a separator, we need a special case for this.
  add: '+'

  /**
   * Modifier keys.
   *
   * @type {Array}
   */

};var MODIFIERS = {
  alt: 'altKey',
  control: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'

  /**
   * Test whether an `event` matches a `hotkey` string.
   *
   * If you omit the `event`, the comparison function will be curried, to improve
   * performance by not having to parse the hotkey string on each invocation.
   *
   * @param {String} hotkey
   * @param {Event} [event]
   * @return {Boolean|Function}
   */

};function isHotkey(hotkey, event) {
  var object = parseHotkey(hotkey);

  return event == null ? function (e) {
    return compareHotkey(object, e);
  } : compareHotkey(object, event);
}

/**
 * Parse a `hotkey` string into an object.
 *
 * @param {String} hotkey
 * @return {Object}
 */

function parseHotkey(hotkey) {
  // Special case to replace `++` with `+add` to handle matching the plus key.
  hotkey = hotkey.replace('++', '+add');

  var values = hotkey.split('+');
  var length = values.length;

  var ret = {};

  // Ensure that any modifier that isn't explicitly set is set to `false`.
  for (var k in MODIFIERS) {
    var m = MODIFIERS[k];
    ret[m] = false;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;

      value = value.toLowerCase();

      if (value == 'mod') {
        value = IS_MAC ? 'cmd' : 'ctrl';
      }

      if (value in CONVENIENCE) {
        value = CONVENIENCE[value];
      }

      var _m = MODIFIERS[value];

      if (length == 1 || !_m) {
        ret.key = value;
      }

      if (_m) {
        ret[_m] = true;
      }

      // If there's only one key, and it's not a modifier, ignore the shift key
      // because it will already be taken into accout by the `event.key` value.
      if (length == 1 && !_m) {
        ret.shiftKey = null;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return ret;
}

/**
 * Compare a hotkey `object` to an `event` to see if they match.
 *
 * @param {Object} object
 * @param {Event} event
 * @return {Boolean}
 */

function compareHotkey(object, event) {
  for (var key in object) {
    var actual = key == 'key' ? event.key.toLowerCase() : event[key];
    var expected = object[key];
    if (expected != null && actual != expected) return false;
  }

  return true;
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = isHotkey;
exports.isHotkey = isHotkey;
exports.parseHotkey = parseHotkey;
exports.compareHotkey = compareHotkey;