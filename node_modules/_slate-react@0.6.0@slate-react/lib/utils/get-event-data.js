'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _transferTypes = require('../constants/transfer-types');

var _transferTypes2 = _interopRequireDefault(_transferTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Fragment matching regexp for HTML nodes.
 *
 * @type {RegExp}
 */

var FRAGMENT_MATCHER = / data-slate-fragment="([^\s"]+)"/;

/**
 * Get the transfer data from an `event`.
 *
 * @param {Event} event
 * @return {Object}
 */

function getEventTransfer(event) {
  if (event.nativeEvent) {
    event = event.nativeEvent;
  }

  var transfer = event.dataTransfer || event.clipboardData;
  var fragment = getType(transfer, _transferTypes2.default.FRAGMENT);
  var node = getType(transfer, _transferTypes2.default.NODE);
  var html = getType(transfer, 'text/html');
  var rich = getType(transfer, 'text/rtf');
  var text = getType(transfer, 'text/plain');
  var files = void 0;

  // If there isn't a fragment, but there is HTML, check to see if the HTML is
  // actually an encoded fragment.
  if (!fragment && html && ~html.indexOf(' data-slate-fragment="')) {
    var matches = FRAGMENT_MATCHER.exec(html);

    var _matches = _slicedToArray(matches, 2),
        full = _matches[0],
        encoded = _matches[1]; // eslint-disable-line no-unused-vars


    if (encoded) fragment = encoded;
  }

  // COMPAT: Edge doesn't handle custom data types
  // These will be embedded in text/plain in this case (2017/7/12)
  if (text) {
    var embeddedTypes = getEmbeddedTypes(text);

    if (embeddedTypes[_transferTypes2.default.FRAGMENT]) fragment = embeddedTypes[_transferTypes2.default.FRAGMENT];
    if (embeddedTypes[_transferTypes2.default.NODE]) node = embeddedTypes[_transferTypes2.default.NODE];
    if (embeddedTypes['text/plain']) text = embeddedTypes['text/plain'];
  }

  // Decode a fragment or node if they exist.
  if (fragment) fragment = _slateBase64Serializer2.default.deserializeNode(fragment);
  if (node) node = _slateBase64Serializer2.default.deserializeNode(node);

  // COMPAT: Edge sometimes throws 'NotSupportedError'
  // when accessing `transfer.items` (2017/7/12)
  try {
    // Get and normalize files if they exist.
    if (transfer.items && transfer.items.length) {
      files = Array.from(transfer.items).map(function (item) {
        return item.kind == 'file' ? item.getAsFile() : null;
      }).filter(function (exists) {
        return exists;
      });
    } else if (transfer.files && transfer.files.length) {
      files = Array.from(transfer.files);
    }
  } catch (err) {
    if (transfer.files && transfer.files.length) {
      files = Array.from(transfer.files);
    }
  }

  // Determine the type of the data.
  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };
  data.type = getTransferType(data);
  return data;
}

/**
 * Takes text input, checks whether contains embedded data
 * and returns object with original text +/- additional data
 *
 * @param {String} text
 * @return {Object}
 */

function getEmbeddedTypes(text) {
  var prefix = 'SLATE-DATA-EMBED::';

  if (text.substring(0, prefix.length) !== prefix) {
    return { 'text/plain': text };
  }

  // Attempt to parse, if fails then just standard text/plain
  // Otherwise, already had data embedded
  try {
    return JSON.parse(text.substring(prefix.length));
  } catch (err) {
    throw new Error('Unable to parse custom embedded drag data');
  }
}

/**
 * Get the type of a transfer from its `data`.
 *
 * @param {Object} data
 * @return {String}
 */

function getTransferType(data) {
  if (data.fragment) return 'fragment';
  if (data.node) return 'node';

  // COMPAT: Microsoft Word adds an image of the selected text to the data.
  // Since files are preferred over HTML or text, this would cause the type to
  // be considered `files`. But it also adds rich text data so we can check
  // for that and properly set the type to `html` or `text`. (2016/11/21)
  if (data.rich && data.html) return 'html';
  if (data.rich && data.text) return 'text';

  if (data.files && data.files.length) return 'files';
  if (data.html) return 'html';
  if (data.text) return 'text';
  return 'unknown';
}

/**
 * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or
 * `text/plain` from transfers's `data` if possible, otherwise return null.
 *
 * @param {Object} transfer
 * @param {String} type
 * @return {String}
 */

function getType(transfer, type) {
  if (!transfer.types || !transfer.types.length) {
    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`
    // is supported`. (2017/06/23)
    return type === 'text/plain' ? transfer.getData('Text') || null : null;
  }

  return transfer.types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = getEventTransfer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9nZXQtZXZlbnQtZGF0YS5qcyJdLCJuYW1lcyI6WyJGUkFHTUVOVF9NQVRDSEVSIiwiZ2V0RXZlbnRUcmFuc2ZlciIsImV2ZW50IiwibmF0aXZlRXZlbnQiLCJ0cmFuc2ZlciIsImRhdGFUcmFuc2ZlciIsImNsaXBib2FyZERhdGEiLCJmcmFnbWVudCIsImdldFR5cGUiLCJGUkFHTUVOVCIsIm5vZGUiLCJOT0RFIiwiaHRtbCIsInJpY2giLCJ0ZXh0IiwiZmlsZXMiLCJpbmRleE9mIiwibWF0Y2hlcyIsImV4ZWMiLCJmdWxsIiwiZW5jb2RlZCIsImVtYmVkZGVkVHlwZXMiLCJnZXRFbWJlZGRlZFR5cGVzIiwiZGVzZXJpYWxpemVOb2RlIiwiaXRlbXMiLCJsZW5ndGgiLCJBcnJheSIsImZyb20iLCJtYXAiLCJpdGVtIiwia2luZCIsImdldEFzRmlsZSIsImZpbHRlciIsImV4aXN0cyIsImVyciIsImRhdGEiLCJ0eXBlIiwiZ2V0VHJhbnNmZXJUeXBlIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiRXJyb3IiLCJ0eXBlcyIsImdldERhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLG1CQUFtQixrQ0FBekI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUM7QUFDL0IsTUFBSUEsTUFBTUMsV0FBVixFQUF1QjtBQUNyQkQsWUFBUUEsTUFBTUMsV0FBZDtBQUNEOztBQUVELE1BQU1DLFdBQVdGLE1BQU1HLFlBQU4sSUFBc0JILE1BQU1JLGFBQTdDO0FBQ0EsTUFBSUMsV0FBV0MsUUFBUUosUUFBUixFQUFrQix3QkFBZUssUUFBakMsQ0FBZjtBQUNBLE1BQUlDLE9BQU9GLFFBQVFKLFFBQVIsRUFBa0Isd0JBQWVPLElBQWpDLENBQVg7QUFDQSxNQUFNQyxPQUFPSixRQUFRSixRQUFSLEVBQWtCLFdBQWxCLENB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bGF0ZS1iYXNlNjQtc2VyaWFsaXplcidcblxuaW1wb3J0IFRSQU5TRkVSX1RZUEVTIGZyb20gJy4uL2NvbnN0YW50cy90cmFuc2Zlci10eXBlcydcblxuLyoqXG4gKiBGcmFnbWVudCBtYXRjaGluZyByZWdleHAgZm9yIEhUTUwgbm9kZXMuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuXG5jb25zdCBGUkFHTUVOVF9NQVRDSEVSID0gLyBkYXRhLXNsYXRlLWZyYWdtZW50PVwiKFteXFxzXCJdKylcIi9cblxuLyoqXG4gKiBHZXQgdGhlIHRyYW5zZmVyIGRhdGEgZnJvbSBhbiBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUcmFuc2ZlcihldmVudCkge1xuICBpZiAoZXZlbnQubmF0aXZlRXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50XG4gIH1cblxuICBjb25zdCB0cmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5jbGlwYm9hcmREYXRhXG4gIGxldCBmcmFnbWVudCA9IGdldFR5cGUodHJhbnNmZXIsIFRSQU5TRkVSX1RZUEVTLkZSQUdNRU5UKVxuICBsZXQgbm9kZSA9IGdldFR5cGUodHJhbnNmZXIsIFRSQU5TRkVSX1RZUEVTLk5PREUpXG4gIGNvbnN0IGh0bWwgPSBnZXRUeXBlKHRyYW5zZmVyLCAndGV4dC9odG1sJylcbiAgY29uc3QgcmljaCA9IGdldFR5cGUodHJhbnNmZXIsICd0ZXh0L3J0ZicpXG4gIGxldCB0ZXh0ID0gZ2V0VHlwZSh0cmFuc2ZlciwgJ3RleHQvcGxhaW4nKVxuICBsZXQgZmlsZXNcblxuICAvLyBJZiB0aGVyZSBpc24ndCBhIGZyYWdtZW50LCBidXQgdGhlcmUgaXMgSFRNTCwgY2hlY2sgdG8gc2VlIGlmIHRoZSBIVE1MIGlzXG4gIC8vIGFjdHVhbGx5IGFuIGVuY29kZWQgZnJhZ21lbnQuXG4gIGlmIChcbiAgICAhZnJhZ21lbnQgJiZcbiAgICBodG1sICYmXG4gICAgfmh0bWwuaW5kZXhPZignIGRhdGEtc2xhdGUtZnJhZ21lbnQ9XCInKVxuICApIHtcbiAgICBjb25zdCBtYXRjaGVzID0gRlJBR01FTlRfTUFUQ0hFUi5leGVjKGh0bWwpXG4gICAgY29uc3QgWyBmdWxsLCBlbmNvZGVkIF0gPSBtYXRjaGVzIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoZW5jb2RlZCkgZnJhZ21lbnQgPSBlbmNvZGVkXG4gIH1cblxuICAvLyBDT01QQVQ6IEVkZ2UgZG9lc24ndCBoYW5kbGUgY3VzdG9tIGRhdGEgdHlwZXNcbiAgLy8gVGhlc2Ugd2lsbCBiZSBlbWJlZGRlZCBpbiB0ZXh0L3BsYWluIGluIHRoaXMgY2FzZSAoMjAxNy83LzEyKVxuICBpZiAodGV4dCkge1xuICAgIGNvbnN0IGVtYmVkZGVkVHlwZXMgPSBnZXRFbWJlZGRlZFR5cGVzKHRleHQpXG5cbiAgICBpZiAoZW1iZWRkZWRUeXBlc1tUUkFOU0ZFUl9UWVBFUy5GUkFHTUVOVF0pIGZyYWdtZW50ID0gZW1iZWRkZWRUeXBlc1tUUkFOU0ZFUl9UWVBFUy5GUkFHTUVOVF1cbiAgICBpZiAoZW1iZWRkZWRUeXBlc1tUUkFOU0ZFUl9UWVBFUy5OT0RFXSkgbm9kZSA9IGVtYmVkZGVkVHlwZXNbVFJBTlNGRVJfVFlQRVMuTk9ERV1cbiAgICBpZiAoZW1iZWRkZWRUeXBlc1sndGV4dC9wbGFpbiddKSB0ZXh0ID0gZW1iZWRkZWRUeXBlc1sndGV4dC9wbGFpbiddXG4gIH1cblxuICAvLyBEZWNvZGUgYSBmcmFnbWVudCBvciBub2RlIGlmIHRoZXkgZXhpc3QuXG4gIGlmIChmcmFnbWVudCkgZnJhZ21lbnQgPSBCYXNlNjQuZGVzZXJpYWxpemVOb2RlKGZyYWdtZW50KVxuICBpZiAobm9kZSkgbm9kZSA9IEJhc2U2NC5kZXNlcmlhbGl6ZU5vZGUobm9kZSlcblxuICAvLyBDT01QQVQ6IEVkZ2Ugc29tZXRpbWVzIHRocm93cyAnTm90U3VwcG9ydGVkRXJyb3InXG4gIC8vIHdoZW4gYWNjZXNzaW5nIGB0cmFuc2Zlci5pdGVtc2AgKDIwMTcvNy8xMilcbiAgdHJ5IHtcbiAgICAvLyBHZXQgYW5kIG5vcm1hbGl6ZSBmaWxlcyBpZiB0aGV5IGV4aXN0LlxuICAgIGlmICh0cmFuc2Zlci5pdGVtcyAmJiB0cmFuc2Zlci5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGZpbGVzID0gQXJyYXkuZnJvbSh0cmFuc2Zlci5pdGVtcylcbiAgICAgICAgLm1hcChpdGVtID0+IGl0ZW0ua2luZCA9PSAnZmlsZScgPyBpdGVtLmdldEFzRmlsZSgpIDogbnVsbClcbiAgICAgICAgLmZpbHRlcihleGlzdHMgPT4gZXhpc3RzKVxuICAgIH0gZWxzZSBpZiAodHJhbnNmZXIuZmlsZXMgJiYgdHJhbnNmZXIuZmlsZXMubGVuZ3RoKSB7XG4gICAgICBmaWxlcyA9IEFycmF5LmZyb20odHJhbnNmZXIuZmlsZXMpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHJhbnNmZXIuZmlsZXMgJiYgdHJhbnNmZXIuZmlsZXMubGVuZ3RoKSB7XG4gICAgICBmaWxlcyA9IEFycmF5LmZyb20odHJhbnNmZXIuZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBkYXRhLlxuICBjb25zdCBkYXRhID0geyBmaWxlcywgZnJhZ21lbnQsIGh0bWwsIG5vZGUsIHJpY2gsIHRleHQgfVxuICBkYXRhLnR5cGUgPSBnZXRUcmFuc2ZlclR5cGUoZGF0YSlcbiAgcmV0dXJuIGRhdGFcbn1cblxuLyoqXG4gKiBUYWtlcyB0ZXh0IGlucHV0LCBjaGVja3Mgd2hldGhlciBjb250YWlucyBlbWJlZGRlZCBkYXRhXG4gKiBhbmQgcmV0dXJucyBvYmplY3Qgd2l0aCBvcmlnaW5hbCB0ZXh0ICsvLSBhZGRpdGlvbmFsIGRhdGFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldEVtYmVkZGVkVHlwZXModGV4dCkge1xuICBjb25zdCBwcmVmaXggPSAnU0xBVEUtREFUQS1FTUJFRDo6J1xuXG4gIGlmICh0ZXh0LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAhPT0gcHJlZml4KSB7XG4gICAgcmV0dXJuIHsgJ3RleHQvcGxhaW4nOiB0ZXh0IH1cbiAgfVxuXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UsIGlmIGZhaWxzIHRoZW4ganVzdCBzdGFuZGFyZCB0ZXh0L3BsYWluXG4gIC8vIE90aGVyd2lzZSwgYWxyZWFkeSBoYWQgZGF0YSBlbWJlZGRlZFxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBjdXN0b20gZW1iZWRkZWQgZHJhZyBkYXRhJylcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhIHRyYW5zZmVyIGZyb20gaXRzIGBkYXRhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldFRyYW5zZmVyVHlwZShkYXRhKSB7XG4gIGlmIChkYXRhLmZyYWdtZW50KSByZXR1cm4gJ2ZyYWdtZW50J1xuICBpZiAoZGF0YS5ub2RlKSByZXR1cm4gJ25vZGUnXG5cbiAgLy8gQ09NUEFUOiBNaWNyb3NvZnQgV29yZCBhZGRzIGFuIGltYWdlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0IHRvIHRoZSBkYXRhLlxuICAvLyBTaW5jZSBmaWxlcyBhcmUgcHJlZmVycmVkIG92ZXIgSFRNTCBvciB0ZXh0LCB0aGlzIHdvdWxkIGNhdXNlIHRoZSB0eXBlIHRvXG4gIC8vIGJlIGNvbnNpZGVyZWQgYGZpbGVzYC4gQnV0IGl0IGFsc28gYWRkcyByaWNoIHRleHQgZGF0YSBzbyB3ZSBjYW4gY2hlY2tcbiAgLy8gZm9yIHRoYXQgYW5kIHByb3Blcmx5IHNldCB0aGUgdHlwZSB0byBgaHRtbGAgb3IgYHRleHRgLiAoMjAxNi8xMS8yMSlcbiAgaWYgKGRhdGEucmljaCAmJiBkYXRhLmh0bWwpIHJldHVybiAnaHRtbCdcbiAgaWYgKGRhdGEucmljaCAmJiBkYXRhLnRleHQpIHJldHVybiAndGV4dCdcblxuICBpZiAoZGF0YS5maWxlcyAmJiBkYXRhLmZpbGVzLmxlbmd0aCkgcmV0dXJuICdmaWxlcydcbiAgaWYgKGRhdGEuaHRtbCkgcmV0dXJuICdodG1sJ1xuICBpZiAoZGF0YS50ZXh0KSByZXR1cm4gJ3RleHQnXG4gIHJldHVybiAndW5rbm93bidcbn1cblxuLyoqXG4gKiBHZXQgb25lIG9mIHR5cGVzIGBUWVBFUy5GUkFHTUVOVGAsIGBUWVBFUy5OT0RFYCwgYHRleHQvaHRtbGAsIGB0ZXh0L3J0ZmAgb3JcbiAqIGB0ZXh0L3BsYWluYCBmcm9tIHRyYW5zZmVycydzIGBkYXRhYCBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2ZlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBnZXRUeXBlKHRyYW5zZmVyLCB0eXBlKSB7XG4gIGlmICghdHJhbnNmZXIudHlwZXMgfHwgIXRyYW5zZmVyLnR5cGVzLmxlbmd0aCkge1xuICAgIC8vIENPTVBBVDogSW4gSUUgMTEsIHRoZXJlIGlzIG5vIGB0eXBlc2AgZmllbGQgYnV0IGBnZXREYXRhKCdUZXh0JylgXG4gICAgLy8gaXMgc3VwcG9ydGVkYC4gKDIwMTcvMDYvMjMpXG4gICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0L3BsYWluJyA/IHRyYW5zZmVyLmdldERhdGEoJ1RleHQnKSB8fCBudWxsIDogbnVsbFxuICB9XG5cbiAgcmV0dXJuIHRyYW5zZmVyLnR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xID8gdHJhbnNmZXIuZ2V0RGF0YSh0eXBlKSB8fCBudWxsIDogbnVsbFxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZ2V0RXZlbnRUcmFuc2ZlclxuIl19