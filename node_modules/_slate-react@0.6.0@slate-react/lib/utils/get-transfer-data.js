'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _transferTypes = require('../constants/transfer-types');

var _transferTypes2 = _interopRequireDefault(_transferTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Fragment matching regexp for HTML nodes.
 *
 * @type {RegExp}
 */

var FRAGMENT_MATCHER = / data-slate-fragment="([^\s"]+)"/;

/**
 * Get the data and type from a native data `transfer`.
 *
 * @param {DataTransfer} transfer
 * @return {Object}
 */

function getTransferData(transfer) {
  var fragment = getType(transfer, _transferTypes2.default.FRAGMENT);
  var node = getType(transfer, _transferTypes2.default.NODE);
  var html = getType(transfer, 'text/html');
  var rich = getType(transfer, 'text/rtf');
  var text = getType(transfer, 'text/plain');
  var files = void 0;

  // If there isn't a fragment, but there is HTML, check to see if the HTML is
  // actually an encoded fragment.
  if (!fragment && html && ~html.indexOf(' data-slate-fragment="')) {
    var matches = FRAGMENT_MATCHER.exec(html);

    var _matches = _slicedToArray(matches, 2),
        full = _matches[0],
        encoded = _matches[1]; // eslint-disable-line no-unused-vars


    if (encoded) fragment = encoded;
  }

  // COMPAT: Edge doesn't handle custom data types
  // These will be embedded in text/plain in this case (2017/7/12)
  if (text) {
    var embeddedTypes = getEmbeddedTypes(text);

    if (embeddedTypes[_transferTypes2.default.FRAGMENT]) fragment = embeddedTypes[_transferTypes2.default.FRAGMENT];
    if (embeddedTypes[_transferTypes2.default.NODE]) node = embeddedTypes[_transferTypes2.default.NODE];
    if (embeddedTypes['text/plain']) text = embeddedTypes['text/plain'];
  }

  // Decode a fragment or node if they exist.
  if (fragment) fragment = _slateBase64Serializer2.default.deserializeNode(fragment);
  if (node) node = _slateBase64Serializer2.default.deserializeNode(node);

  // COMPAT: Edge sometimes throws 'NotSupportedError'
  // when accessing `transfer.items` (2017/7/12)
  try {
    // Get and normalize files if they exist.
    if (transfer.items && transfer.items.length) {
      files = Array.from(transfer.items).map(function (item) {
        return item.kind == 'file' ? item.getAsFile() : null;
      }).filter(function (exists) {
        return exists;
      });
    } else if (transfer.files && transfer.files.length) {
      files = Array.from(transfer.files);
    }
  } catch (err) {
    if (transfer.files && transfer.files.length) {
      files = Array.from(transfer.files);
    }
  }

  // Determine the type of the data.
  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };
  data.type = getTransferType(data);
  return data;
}

/**
 * Takes text input, checks whether contains embedded data
 * and returns object with original text +/- additional data
 *
 * @param {String} text
 * @return {Object}
 */

function getEmbeddedTypes(text) {
  var prefix = 'SLATE-DATA-EMBED::';

  if (text.substring(0, prefix.length) !== prefix) {
    return { 'text/plain': text };
  }

  // Attempt to parse, if fails then just standard text/plain
  // Otherwise, already had data embedded
  try {
    return JSON.parse(text.substring(prefix.length));
  } catch (err) {
    throw new Error('Unable to parse custom embedded drag data');
  }
}

/**
 * Get the type of a transfer from its `data`.
 *
 * @param {Object} data
 * @return {String}
 */

function getTransferType(data) {
  if (data.fragment) return 'fragment';
  if (data.node) return 'node';

  // COMPAT: Microsoft Word adds an image of the selected text to the data.
  // Since files are preferred over HTML or text, this would cause the type to
  // be considered `files`. But it also adds rich text data so we can check
  // for that and properly set the type to `html` or `text`. (2016/11/21)
  if (data.rich && data.html) return 'html';
  if (data.rich && data.text) return 'text';

  if (data.files && data.files.length) return 'files';
  if (data.html) return 'html';
  if (data.text) return 'text';
  return 'unknown';
}

/**
 * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or
 * `text/plain` from transfers's `data` if possible, otherwise return null.
 *
 * @param {Object} transfer
 * @param {String} type
 * @return {String}
 */

function getType(transfer, type) {
  if (!transfer.types || !transfer.types.length) {
    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`
    // is supported`. (2017/06/23)
    return type === 'text/plain' ? transfer.getData('Text') || null : null;
  }

  return transfer.types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;
}

/**
 * Export.
 *
 * @type {Function}
 */

exports.default = getTransferData;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9nZXQtdHJhbnNmZXItZGF0YS5qcyJdLCJuYW1lcyI6WyJGUkFHTUVOVF9NQVRDSEVSIiwiZ2V0VHJhbnNmZXJEYXRhIiwidHJhbnNmZXIiLCJmcmFnbWVudCIsImdldFR5cGUiLCJGUkFHTUVOVCIsIm5vZGUiLCJOT0RFIiwiaHRtbCIsInJpY2giLCJ0ZXh0IiwiZmlsZXMiLCJpbmRleE9mIiwibWF0Y2hlcyIsImV4ZWMiLCJmdWxsIiwiZW5jb2RlZCIsImVtYmVkZGVkVHlwZXMiLCJnZXRFbWJlZGRlZFR5cGVzIiwiZGVzZXJpYWxpemVOb2RlIiwiaXRlbXMiLCJsZW5ndGgiLCJBcnJheSIsImZyb20iLCJtYXAiLCJpdGVtIiwia2luZCIsImdldEFzRmlsZSIsImZpbHRlciIsImV4aXN0cyIsImVyciIsImRhdGEiLCJ0eXBlIiwiZ2V0VHJhbnNmZXJUeXBlIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiRXJyb3IiLCJ0eXBlcyIsImdldERhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLG1CQUFtQixrQ0FBekI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxlQUFULENBQXlCQyxRQUF6QixFQUFtQztBQUNqQyxNQUFJQyxXQUFXQyxRQUFRRixRQUFSLEVBQWtCLHdCQUFlRyxRQUFqQyxDQUFmO0FBQ0EsTUFBSUMsT0FBT0YsUUFBUUYsUUFBUixFQUFrQix3QkFBZUssSUFBakMsQ0FBWDtBQUNBLE1BQU1DLE9BQU9KLFFBQVFGLFFBQVIsRUFBa0IsV0FBbEIsQ0FBYjtBQUNBLE1BQU1PLE9BQU9MLFFBQVFGLFFBQVIsRUFBa0IsVUFBbEIsQ0FBYjtBQUNBLE1BQUlRLE9BQU9OLFFBQVFGLFFBQVIsRUFBa0IsWUFBbEIsQ0FBWDtBQUNBLE1BQUlTLGNBQUo7O0FBRUE7QUFDQTtBQUNBLE1BQ0UsQ0FBQ1IsUUFBRCxJQUNBSyxJQURBLElBRUEsQ0FBQ0EsS0FBS0ksT0FBTCxDQUFhLHdCQUFiLENBSEgsRUFJRTtBQUNBLFFBQU1DLFVBQVViLGlCQUFpQmMsSUFBakIsQ0FBc0JOLElBQXRCLENBQWhCOztBQURBLGtDQUUwQkssT0FGMUI7QUFBQSxRQUVRRSxJQUZSO0FBQUEsUUFFY0MsT0FGZCxnQkFFa0M7OztBQUNsQyxRQUFJQSxPQUFKLEVBQWFiLFdBQVdhLE9BQVg7QUFDZDs7QUFFRDtBQUNBO0FBQ0EsTUFBSU4sSUFBSixFQUFVO0FBQ1IsUUFBTU8sZ0JBQWdCQyxpQkFBaUJSLElBQWpCLENBQXRCOztBQUVBLFFBQUlPLGNBQWMsd0JBQWVaLFFBQTdCLENBQUosRUFBNENGLFdBQVdjLGNBQWMsd0JBQWVaLFFBQTdCLENBQVg7QUFDNUMsUUFBSVksY0FBYyx3QkFBZVYsSUFBN0IsQ0FBSixFQUF3Q0QsT0FBT1csY0FBYyx3QkFBZVYsSUFBN0IsQ0FBUDtBQUN4QyxRQUFJVSxjQUFjLFlBQWQsQ0FBSixFQUFpQ1AsT0FBT08sY0FBYyxZQUFkLENBQVA7QUFDbEM7O0FBRUQ7QUFDQSxNQUFJZCxRQUFKLEVBQWNBLFdBQVcsZ0NBQU9nQixlQUFQLENBQXVCaEIsUUFBdkIsQ0FBWDtBQUNkLE1BQUlHLElBQUosRUFBVUEsT0FBTyxnQ0FBT2EsZUFBUCxDQUF1QmIsSUFBdkIsQ0FBUDs7QUFFVjtBQUNBO0FBQ0EsTUFBSTtBQUNGO0FBQ0EsUUFBSUosU0FBU2tCLEtBQVQsSUFBa0JsQixTQUFTa0IsS0FBVCxDQUFlQyxNQUFyQyxFQUE2QztBQUMzQ1YsY0FBUVcsTUFBTUMsSUFBTixDQUFXckIsU0FBU2tCLEtBQXBCLEVBQ0xJLEdBREssQ0FDRDtBQUFBLGVBQVFDLEtBQUtDLElBQUwsSUFBYSxNQUFiLEdBQXNCRCxLQUFLRSxTQUFMLEVBQXRCLEdBQXlDLElBQWpEO0FBQUEsT0FEQyxFQUVMQyxNQUZLLENBRUU7QUFBQSxlQUFVQyxNQUFWO0FBQUEsT0FGRixDQUFSO0FBR0QsS0FKRCxNQUlPLElBQUkzQixTQUFTUyxLQUFULElBQWtCVCxTQUFTUyxLQUFULENBQWVVLE1BQXJDLEVBQTZDO0FBQ2xEVixjQUFRVyxNQUFNQyxJQUFOLENBQVdyQixTQUFTUyxLQUFwQixDQUFSO0FBQ0Q7QUFDRixHQVRELENBU0UsT0FBT21CLEdBQVAsRUFBWTtBQUNaLFFBQUk1QixTQUFTUyxLQUFULElBQWtCVCxTQUFTUyxLQUFULENBQWVVLE1BQXJDLEVBQTZDO0FBQzNDVixjQUFRVyxNQUFNQyxJQUFOLENBQVdyQixTQUFTUyxLQUFwQixDQUFSO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLE1BQU1vQixPQUFPLEVBQUVwQixZQUFGLEVBQVNSLGtCQUFULEVBQW1CSyxVQUFuQixFQUF5QkYsVUFBekIsRUFBK0JHLFVBQS9CLEVBQXFDQyxVQUFyQyxFQUFiO0FBQ0FxQixPQUFLQyxJQUFMLEdBQVlDLGdCQUFnQkYsSUFBaEIsQ0FBWjtBQUNBLFNBQU9BLElBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTYixnQkFBVCxDQUEwQlIsSUFBMUIsRUFBZ0M7QUFDOUIsTUFBTXdCLFNBQVMsb0JBQWY7O0FBRUEsTUFBSXhCLEtBQUt5QixTQUFMLENBQWUsQ0FBZixFQUFrQkQsT0FBT2IsTUFBekIsTUFBcUNhLE1BQXpDLEVBQWlEO0FBQy9DLFdBQU8sRUFBRSxjQUFjeEIsSUFBaEIsRUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxNQUFJO0FBQ0YsV0FBTzBCLEtBQUtDLEtBQUwsQ0FBVzNCLEtBQUt5QixTQUFMLENBQWVELE9BQU9iLE1BQXRCLENBQVgsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPUyxHQUFQLEVBQVk7QUFDWixVQUFNLElBQUlRLEtBQUosQ0FBVSwyQ0FBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztBQU9BLFNBQVNMLGVBQVQsQ0FBeUJGLElBQXpCLEVBQStCO0FBQzdCLE1BQUlBLEtBQUs1QixRQUFULEVBQW1CLE9BQU8sVUFBUDtBQUNuQixNQUFJNEIsS0FBS3pCLElBQVQsRUFBZSxPQUFPLE1BQVA7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJeUIsS0FBS3RCLElBQUwsSUFBYXNCLEtBQUt2QixJQUF0QixFQUE0QixPQUFPLE1BQVA7QUFDNUIsTUFBSXVCLEtBQUt0QixJQUFMLElBQWFzQixLQUFLckIsSUFBdEIsRUFBNEIsT0FBTyxNQUFQOztBQUU1QixNQUFJcUIsS0FBS3BCLEtBQUwsSUFBY29CLEtBQUtwQixLQUFMLENBQVdVLE1BQTdCLEVBQXFDLE9BQU8sT0FBUDtBQUNyQyxNQUFJVSxLQUFLdkIsSUFBVCxFQUFlLE9BQU8sTUFBUDtBQUNmLE1BQUl1QixLQUFLckIsSUFBVCxFQUFlLE9BQU8sTUFBUDtBQUNmLFNBQU8sU0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTTixPQUFULENBQWlCRixRQUFqQixFQUEyQjhCLElBQTNCLEVBQWlDO0FBQy9CLE1BQUksQ0FBQzlCLFNBQVNxQyxLQUFWLElBQW1CLENBQUNyQyxTQUFTcUMsS0FBVCxDQUFlbEIsTUFBdkMsRUFBK0M7QUFDN0M7QUFDQTtBQUNBLFdBQU9XLFNBQVMsWUFBVCxHQUF3QjlCLFNBQVNzQyxPQUFULENBQWlCLE1BQWpCLEtBQTRCLElBQXBELEdBQTJELElBQWxFO0FBQ0Q7O0FBRUQsU0FBT3RDLFNBQVNxQyxLQUFULENBQWUzQixPQUFmLENBQXVCb0IsSUFBdkIsTUFBaUMsQ0FBQyxDQUFsQyxHQUFzQzlCLFNBQVNzQyxPQUFULENBQWlCUixJQUFqQixLQUEwQixJQUFoRSxHQUF1RSxJQUE5RTtBQUNEOztBQUVEOzs7Ozs7a0JBTWUvQixlIiwiZmlsZSI6ImdldC10cmFuc2Zlci1kYXRhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgQmFzZTY0IGZyb20gJ3NsYXRlLWJhc2U2NC1zZXJpYWxpemVyJ1xuXG5pbXBvcnQgVFJBTlNGRVJfVFlQRVMgZnJvbSAnLi4vY29uc3RhbnRzL3RyYW5zZmVyLXR5cGVzJ1xuXG4vKipcbiAqIEZyYWdtZW50IG1hdGNoaW5nIHJlZ2V4cCBmb3IgSFRNTCBub2Rlcy5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5cbmNvbnN0IEZSQUdNRU5UX01BVENIRVIgPSAvIGRhdGEtc2xhdGUtZnJhZ21lbnQ9XCIoW15cXHNcIl0rKVwiL1xuXG4vKipcbiAqIEdldCB0aGUgZGF0YSBhbmQgdHlwZSBmcm9tIGEgbmF0aXZlIGRhdGEgYHRyYW5zZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGFUcmFuc2Zlcn0gdHJhbnNmZXJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRUcmFuc2ZlckRhdGEodHJhbnNmZXIpIHtcbiAgbGV0IGZyYWdtZW50ID0gZ2V0VHlwZSh0cmFuc2ZlciwgVFJBTlNGRVJfVFlQRVMuRlJBR01FTlQpXG4gIGxldCBub2RlID0gZ2V0VHlwZSh0cmFuc2ZlciwgVFJBTlNGRVJfVFlQRVMuTk9ERSlcbiAgY29uc3QgaHRtbCA9IGdldFR5cGUodHJhbnNmZXIsICd0ZXh0L2h0bWwnKVxuICBjb25zdCByaWNoID0gZ2V0VHlwZSh0cmFuc2ZlciwgJ3RleHQvcnRmJylcbiAgbGV0IHRleHQgPSBnZXRUeXBlKHRyYW5zZmVyLCAndGV4dC9wbGFpbicpXG4gIGxldCBmaWxlc1xuXG4gIC8vIElmIHRoZXJlIGlzbid0IGEgZnJhZ21lbnQsIGJ1dCB0aGVyZSBpcyBIVE1MLCBjaGVjayB0byBzZWUgaWYgdGhlIEhUTUwgaXNcbiAgLy8gYWN0dWFsbHkgYW4gZW5jb2RlZCBmcmFnbWVudC5cbiAgaWYgKFxuICAgICFmcmFnbWVudCAmJlxuICAgIGh0bWwgJiZcbiAgICB+aHRtbC5pbmRleE9mKCcgZGF0YS1zbGF0ZS1mcmFnbWVudD1cIicpXG4gICkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBGUkFHTUVOVF9NQVRDSEVSLmV4ZWMoaHRtbClcbiAgICBjb25zdCBbIGZ1bGwsIGVuY29kZWQgXSA9IG1hdGNoZXMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChlbmNvZGVkKSBmcmFnbWVudCA9IGVuY29kZWRcbiAgfVxuXG4gIC8vIENPTVBBVDogRWRnZSBkb2Vzbid0IGhhbmRsZSBjdXN0b20gZGF0YSB0eXBlc1xuICAvLyBUaGVzZSB3aWxsIGJlIGVtYmVkZGVkIGluIHRleHQvcGxhaW4gaW4gdGhpcyBjYXNlICgyMDE3LzcvMTIpXG4gIGlmICh0ZXh0KSB7XG4gICAgY29uc3QgZW1iZWRkZWRUeXBlcyA9IGdldEVtYmVkZGVkVHlwZXModGV4dClcblxuICAgIGlmIChlbWJlZGRlZFR5cGVzW1RSQU5TRkVSX1RZUEVTLkZSQUdNRU5UXSkgZnJhZ21lbnQgPSBlbWJlZGRlZFR5cGVzW1RSQU5TRkVSX1RZUEVTLkZSQUdNRU5UXVxuICAgIGlmIChlbWJlZGRlZFR5cGVzW1RSQU5TRkVSX1RZUEVTLk5PREVdKSBub2RlID0gZW1iZWRkZWRUeXBlc1tUUkFOU0ZFUl9UWVBFUy5OT0RFXVxuICAgIGlmIChlbWJlZGRlZFR5cGVzWyd0ZXh0L3BsYWluJ10pIHRleHQgPSBlbWJlZGRlZFR5cGVzWyd0ZXh0L3BsYWluJ11cbiAgfVxuXG4gIC8vIERlY29kZSBhIGZyYWdtZW50IG9yIG5vZGUgaWYgdGhleSBleGlzdC5cbiAgaWYgKGZyYWdtZW50KSBmcmFnbWVudCA9IEJhc2U2NC5kZXNlcmlhbGl6ZU5vZGUoZnJhZ21lbnQpXG4gIGlmIChub2RlKSBub2RlID0gQmFzZTY0LmRlc2VyaWFsaXplTm9kZShub2RlKVxuXG4gIC8vIENPTVBBVDogRWRnZSBzb21ldGltZXMgdGhyb3dzICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgLy8gd2hlbiBhY2Nlc3NpbmcgYHRyYW5zZmVyLml0ZW1zYCAoMjAxNy83LzEyKVxuICB0cnkge1xuICAgIC8vIEdldCBhbmQgbm9ybWFsaXplIGZpbGVzIGlmIHRoZXkgZXhpc3QuXG4gICAgaWYgKHRyYW5zZmVyLml0ZW1zICYmIHRyYW5zZmVyLml0ZW1zLmxlbmd0aCkge1xuICAgICAgZmlsZXMgPSBBcnJheS5mcm9tKHRyYW5zZmVyLml0ZW1zKVxuICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbS5raW5kID09ICdmaWxlJyA/IGl0ZW0uZ2V0QXNGaWxlKCkgOiBudWxsKVxuICAgICAgICAuZmlsdGVyKGV4aXN0cyA9PiBleGlzdHMpXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zlci5maWxlcyAmJiB0cmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgIGZpbGVzID0gQXJyYXkuZnJvbSh0cmFuc2Zlci5maWxlcylcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0cmFuc2Zlci5maWxlcyAmJiB0cmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgIGZpbGVzID0gQXJyYXkuZnJvbSh0cmFuc2Zlci5maWxlcylcbiAgICB9XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIGRhdGEuXG4gIGNvbnN0IGRhdGEgPSB7IGZpbGVzLCBmcmFnbWVudCwgaHRtbCwgbm9kZSwgcmljaCwgdGV4dCB9XG4gIGRhdGEudHlwZSA9IGdldFRyYW5zZmVyVHlwZShkYXRhKVxuICByZXR1cm4gZGF0YVxufVxuXG4vKipcbiAqIFRha2VzIHRleHQgaW5wdXQsIGNoZWNrcyB3aGV0aGVyIGNvbnRhaW5zIGVtYmVkZGVkIGRhdGFcbiAqIGFuZCByZXR1cm5zIG9iamVjdCB3aXRoIG9yaWdpbmFsIHRleHQgKy8tIGFkZGl0aW9uYWwgZGF0YVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZ2V0RW1iZWRkZWRUeXBlcyh0ZXh0KSB7XG4gIGNvbnN0IHByZWZpeCA9ICdTTEFURS1EQVRBLUVNQkVEOjonXG5cbiAgaWYgKHRleHQuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpICE9PSBwcmVmaXgpIHtcbiAgICByZXR1cm4geyAndGV4dC9wbGFpbic6IHRleHQgfVxuICB9XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSwgaWYgZmFpbHMgdGhlbiBqdXN0IHN0YW5kYXJkIHRleHQvcGxhaW5cbiAgLy8gT3RoZXJ3aXNlLCBhbHJlYWR5IGhhZCBkYXRhIGVtYmVkZGVkXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dC5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIGN1c3RvbSBlbWJlZGRlZCBkcmFnIGRhdGEnKVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIGEgdHJhbnNmZXIgZnJvbSBpdHMgYGRhdGFgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJUeXBlKGRhdGEpIHtcbiAgaWYgKGRhdGEuZnJhZ21lbnQpIHJldHVybiAnZnJhZ21lbnQnXG4gIGlmIChkYXRhLm5vZGUpIHJldHVybiAnbm9kZSdcblxuICAvLyBDT01QQVQ6IE1pY3Jvc29mdCBXb3JkIGFkZHMgYW4gaW1hZ2Ugb2YgdGhlIHNlbGVjdGVkIHRleHQgdG8gdGhlIGRhdGEuXG4gIC8vIFNpbmNlIGZpbGVzIGFyZSBwcmVmZXJyZWQgb3ZlciBIVE1MIG9yIHRleHQsIHRoaXMgd291bGQgY2F1c2UgdGhlIHR5cGUgdG9cbiAgLy8gYmUgY29uc2lkZXJlZCBgZmlsZXNgLiBCdXQgaXQgYWxzbyBhZGRzIHJpY2ggdGV4dCBkYXRhIHNvIHdlIGNhbiBjaGVja1xuICAvLyBmb3IgdGhhdCBhbmQgcHJvcGVybHkgc2V0IHRoZSB0eXBlIHRvIGBodG1sYCBvciBgdGV4dGAuICgyMDE2LzExLzIxKVxuICBpZiAoZGF0YS5yaWNoICYmIGRhdGEuaHRtbCkgcmV0dXJuICdodG1sJ1xuICBpZiAoZGF0YS5yaWNoICYmIGRhdGEudGV4dCkgcmV0dXJuICd0ZXh0J1xuXG4gIGlmIChkYXRhLmZpbGVzICYmIGRhdGEuZmlsZXMubGVuZ3RoKSByZXR1cm4gJ2ZpbGVzJ1xuICBpZiAoZGF0YS5odG1sKSByZXR1cm4gJ2h0bWwnXG4gIGlmIChkYXRhLnRleHQpIHJldHVybiAndGV4dCdcbiAgcmV0dXJuICd1bmtub3duJ1xufVxuXG4vKipcbiAqIEdldCBvbmUgb2YgdHlwZXMgYFRZUEVTLkZSQUdNRU5UYCwgYFRZUEVTLk5PREVgLCBgdGV4dC9odG1sYCwgYHRleHQvcnRmYCBvclxuICogYHRleHQvcGxhaW5gIGZyb20gdHJhbnNmZXJzJ3MgYGRhdGFgIGlmIHBvc3NpYmxlLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGdldFR5cGUodHJhbnNmZXIsIHR5cGUpIHtcbiAgaWYgKCF0cmFuc2Zlci50eXBlcyB8fCAhdHJhbnNmZXIudHlwZXMubGVuZ3RoKSB7XG4gICAgLy8gQ09NUEFUOiBJbiBJRSAxMSwgdGhlcmUgaXMgbm8gYHR5cGVzYCBmaWVsZCBidXQgYGdldERhdGEoJ1RleHQnKWBcbiAgICAvLyBpcyBzdXBwb3J0ZWRgLiAoMjAxNy8wNi8yMylcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHQvcGxhaW4nID8gdHJhbnNmZXIuZ2V0RGF0YSgnVGV4dCcpIHx8IG51bGwgOiBudWxsXG4gIH1cblxuICByZXR1cm4gdHJhbnNmZXIudHlwZXMuaW5kZXhPZih0eXBlKSAhPT0gLTEgPyB0cmFuc2Zlci5nZXREYXRhKHR5cGUpIHx8IG51bGwgOiBudWxsXG59XG5cbi8qKlxuICogRXhwb3J0LlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBnZXRUcmFuc2ZlckRhdGFcbiJdfQ==