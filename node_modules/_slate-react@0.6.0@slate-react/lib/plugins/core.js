'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slateBase64Serializer = require('slate-base64-serializer');

var _slateBase64Serializer2 = _interopRequireDefault(_slateBase64Serializer);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _slatePlainSerializer = require('slate-plain-serializer');

var _slatePlainSerializer2 = _interopRequireDefault(_slatePlainSerializer);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _getWindow = require('get-window');

var _getWindow2 = _interopRequireDefault(_getWindow);

var _slate = require('slate');

var _content = require('../components/content');

var _content2 = _interopRequireDefault(_content);

var _placeholder = require('../components/placeholder');

var _placeholder2 = _interopRequireDefault(_placeholder);

var _findDomNode = require('../utils/find-dom-node');

var _findDomNode2 = _interopRequireDefault(_findDomNode);

var _environment = require('../constants/environment');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:core');

/**
 * The default plugin.
 *
 * @param {Object} options
 *   @property {Element} placeholder
 *   @property {String} placeholderClassName
 *   @property {Object} placeholderStyle
 * @return {Object}
 */

function Plugin() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var placeholder = options.placeholder,
      placeholderClassName = options.placeholderClassName,
      placeholderStyle = options.placeholderStyle;

  /**
   * On before change, enforce the editor's schema.
   *
   * @param {Change} change
   * @param {Editor} schema
   */

  function onBeforeChange(change, editor) {
    var state = change.state;

    var schema = editor.getSchema();
    var prevState = editor.getState();

    // PERF: Skip normalizing if the document hasn't changed, since schemas only
    // normalize changes to the document, not selection.
    if (prevState && state.document == prevState.document) return;

    change.normalize(_slate.coreSchema);
    change.normalize(schema);
    debug('onBeforeChange');
  }

  /**
   * On before input, correct any browser inconsistencies.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onBeforeInput(e, data, change) {
    debug('onBeforeInput', { data: data });

    // React's `onBeforeInput` synthetic event is based on the native `keypress`
    // and `textInput` events. In browsers that support the native `beforeinput`
    // event, we instead use that event to trigger text insertion, since it
    // provides more useful information about the range being affected and also
    // preserves compatibility with iOS autocorrect, which would be broken if we
    // called `preventDefault()` on React's synthetic event here.
    if (_environment.SUPPORTED_EVENTS.beforeinput) return;

    e.preventDefault();
    change.insertText(e.data);
  }

  /**
   * On blur.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onBlur(e, data, change) {
    debug('onBlur', { data: data });
    change.blur();
  }

  /**
   * On copy.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onCopy(e, data, change) {
    debug('onCopy', data);
    onCutOrCopy(e, data, change);
  }

  /**
   * On cut.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   * @param {Editor} editor
   */

  function onCut(e, data, change, editor) {
    debug('onCut', data);
    onCutOrCopy(e, data, change);
    var window = (0, _getWindow2.default)(e.target);

    // Once the fake cut content has successfully been added to the clipboard,
    // delete the content in the current selection.
    window.requestAnimationFrame(function () {
      editor.change(function (t) {
        return t.delete();
      });
    });
  }

  /**
   * On cut or copy, create a fake selection so that we can add a Base 64
   * encoded copy of the fragment to the HTML, to decode on future pastes.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onCutOrCopy(e, data, change) {
    var window = (0, _getWindow2.default)(e.target);
    var native = window.getSelection();
    var state = change.state;
    var startKey = state.startKey,
        endKey = state.endKey,
        startText = state.startText,
        endBlock = state.endBlock,
        endInline = state.endInline;

    var isVoidBlock = endBlock && endBlock.isVoid;
    var isVoidInline = endInline && endInline.isVoid;
    var isVoid = isVoidBlock || isVoidInline;

    // If the selection is collapsed, and it isn't inside a void node, abort.
    if (native.isCollapsed && !isVoid) return;

    var fragment = data.fragment;

    var encoded = _slateBase64Serializer2.default.serializeNode(fragment);
    var range = native.getRangeAt(0);
    var contents = range.cloneContents();
    var attach = contents.childNodes[0];

    // If the end node is a void node, we need to move the end of the range from
    // the void node's spacer span, to the end of the void node's content.
    if (isVoid) {
      var _r = range.cloneRange();
      var n = isVoidBlock ? endBlock : endInline;
      var node = (0, _findDomNode2.default)(n);
      _r.setEndAfter(node);
      contents = _r.cloneContents();
      attach = contents.childNodes[contents.childNodes.length - 1].firstChild;
    }

    // COMPAT: in Safari and Chrome when selecting a single marked word,
    // marks are not preserved when copying.
    // If the attatched is not void, and the startKey and endKey is the same,
    // check if there is marks involved. If so, set the range start just before the
    // startText node
    if ((_environment.IS_CHROME || _environment.IS_SAFARI) && !isVoid && startKey === endKey) {
      var hasMarks = startText.characters.slice(state.selection.anchorOffset, state.selection.focusOffset).filter(function (char) {
        return char.marks.size !== 0;
      }).size !== 0;
      if (hasMarks) {
        var _r2 = range.cloneRange();
        var _node = (0, _findDomNode2.default)(startText);
        _r2.setStartBefore(_node);
        contents = _r2.cloneContents();
        attach = contents.childNodes[contents.childNodes.length - 1].firstChild;
      }
    }

    // Remove any zero-width space spans from the cloned DOM so that they don't
    // show up elsewhere when pasted.
    var zws = [].slice.call(contents.querySelectorAll('[data-slate-zero-width]'));
    zws.forEach(function (zw) {
      return zw.parentNode.removeChild(zw);
    });

    // COMPAT: In Chrome and Safari, if the last element in the selection to
    // copy has `contenteditable="false"` the copy will fail, and nothing will
    // be put in the clipboard. So we remove them all. (2017/05/04)
    if (_environment.IS_CHROME || _environment.IS_SAFARI) {
      var els = [].slice.call(contents.querySelectorAll('[contenteditable="false"]'));
      els.forEach(function (el) {
        return el.removeAttribute('contenteditable');
      });
    }

    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up
    // in the HTML, and can be used for intra-Slate pasting. If it's a text
    // node, wrap it in a `<span>` so we have something to set an attribute on.
    if (attach.nodeType == 3) {
      var span = window.document.createElement('span');

      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style
      // then leading and trailing spaces will be ignored. (2017/09/21)
      span.style.whiteSpace = 'pre';

      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }

    attach.setAttribute('data-slate-fragment', encoded);

    // Add the phony content to the DOM, and select it, so it will be copied.
    var body = window.document.querySelector('body');
    var div = window.document.createElement('div');
    div.setAttribute('contenteditable', true);
    div.style.position = 'absolute';
    div.style.left = '-9999px';
    div.appendChild(contents);
    body.appendChild(div);

    // COMPAT: In Firefox, trying to use the terser `native.selectAllChildren`
    // throws an error, so we use the older `range` equivalent. (2016/06/21)
    var r = window.document.createRange();
    r.selectNodeContents(div);
    native.removeAllRanges();
    native.addRange(r);

    // Revert to the previous selection right after copying.
    window.requestAnimationFrame(function () {
      body.removeChild(div);
      native.removeAllRanges();
      native.addRange(range);
    });
  }

  /**
   * On drop.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onDrop(e, data, change) {
    debug('onDrop', { data: data });

    switch (data.type) {
      case 'text':
      case 'html':
        return onDropText(e, data, change);
      case 'fragment':
        return onDropFragment(e, data, change);
      case 'node':
        return onDropNode(e, data, change);
    }
  }

  /**
   * On drop node, insert the node wherever it is dropped.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onDropNode(e, data, change) {
    debug('onDropNode', { data: data });

    var state = change.state;
    var selection = state.selection;
    var node = data.node,
        target = data.target,
        isInternal = data.isInternal;

    // If the drag is internal and the target is after the selection, it
    // needs to account for the selection's content being deleted.

    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {
      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset + selection.startOffset : 0 - selection.endOffset);
    }

    if (isInternal) {
      change.delete();
    }

    if (_slate.Block.isBlock(node)) {
      change.select(target).focus().insertBlock(node).removeNodeByKey(node.key);
    }

    if (_slate.Inline.isInline(node)) {
      change.select(target).focus().insertInline(node).removeNodeByKey(node.key);
    }
  }

  /**
   * On drop fragment.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onDropFragment(e, data, change) {
    debug('onDropFragment', { data: data });

    var state = change.state;
    var selection = state.selection;
    var fragment = data.fragment,
        target = data.target,
        isInternal = data.isInternal;

    // If the drag is internal and the target is after the selection, it
    // needs to account for the selection's content being deleted.

    if (isInternal && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {
      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset + selection.startOffset : 0 - selection.endOffset);
    }

    if (isInternal) {
      change.delete();
    }

    change.select(target).focus().insertFragment(fragment);
  }

  /**
   * On drop text, split the blocks at new lines.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onDropText(e, data, change) {
    debug('onDropText', { data: data });

    var state = change.state;
    var document = state.document;
    var text = data.text,
        target = data.target;
    var anchorKey = target.anchorKey;


    change.select(target).focus();

    var hasVoidParent = document.hasVoidParent(anchorKey);

    // Insert text into nearest text node
    if (hasVoidParent) {
      var node = document.getNode(anchorKey);

      while (hasVoidParent) {
        node = document.getNextText(node.key);
        if (!node) break;
        hasVoidParent = document.hasVoidParent(node.key);
      }

      if (node) change.collapseToStartOf(node);
    }

    text.split('\n').forEach(function (line, i) {
      if (i > 0) change.splitBlock();
      change.insertText(line);
    });
  }

  /**
   * On key down.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDown(e, data, change) {
    debug('onKeyDown', { data: data });

    switch (e.key) {
      case 'Enter':
        return onKeyDownEnter(e, data, change);
      case 'Backspace':
        return onKeyDownBackspace(e, data, change);
      case 'Delete':
        return onKeyDownDelete(e, data, change);
      case 'ArrowLeft':
        return onKeyDownLeft(e, data, change);
      case 'ArrowRight':
        return onKeyDownRight(e, data, change);
      case 'ArrowUp':
        return onKeyDownUp(e, data, change);
      case 'ArrowDown':
        return onKeyDownDown(e, data, change);
      case 'd':
        return onKeyDownD(e, data, change);
      case 'h':
        return onKeyDownH(e, data, change);
      case 'k':
        return onKeyDownK(e, data, change);
      case 'y':
        return onKeyDownY(e, data, change);
      case 'z':
      case 'Z':
        return onKeyDownZ(e, data, change);
    }
  }

  /**
   * On `enter` key down, split the current block in half.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownEnter(e, data, change) {
    var state = change.state;
    var document = state.document,
        startKey = state.startKey;

    var hasVoidParent = document.hasVoidParent(startKey);

    // For void nodes, we don't want to split. Instead we just move to the start
    // of the next text node if one exists.
    if (hasVoidParent) {
      var text = document.getNextText(startKey);
      if (!text) return;
      change.collapseToStartOf(text);
      return;
    }

    change.splitBlock();
  }

  /**
   * On `backspace` key down, delete backwards.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownBackspace(e, data, change) {
    var isWord = _environment.IS_MAC ? e.altKey : e.ctrlKey;
    var isLine = _environment.IS_MAC ? e.metaKey : false;

    var boundary = 'Char';
    if (isWord) boundary = 'Word';
    if (isLine) boundary = 'Line';

    change['delete' + boundary + 'Backward']();
  }

  /**
   * On `delete` key down, delete forwards.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownDelete(e, data, change) {
    var isWord = _environment.IS_MAC ? e.altKey : e.ctrlKey;
    var isLine = _environment.IS_MAC ? e.metaKey : false;

    var boundary = 'Char';
    if (isWord) boundary = 'Word';
    if (isLine) boundary = 'Line';

    change['delete' + boundary + 'Forward']();
  }

  /**
   * On `left` key down, move backward.
   *
   * COMPAT: This is required to make navigating with the left arrow work when
   * a void node is selected.
   *
   * COMPAT: This is also required to solve for the case where an inline node is
   * surrounded by empty text nodes with zero-width spaces in them. Without this
   * the zero-width spaces will cause two arrow keys to jump to the next text.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownLeft(e, data, change) {
    var state = change.state;


    if (e.ctrlKey) return;
    if (e.altKey) return;
    if (state.isExpanded) return;

    var document = state.document,
        startKey = state.startKey,
        startText = state.startText;

    var hasVoidParent = document.hasVoidParent(startKey);

    // If the current text node is empty, or we're inside a void parent, we're
    // going to need to handle the selection behavior.
    if (startText.text == '' || hasVoidParent) {
      e.preventDefault();
      var previous = document.getPreviousText(startKey);

      // If there's no previous text node in the document, abort.
      if (!previous) return;

      // If the previous text is in the current block, and inside a non-void
      // inline node, move one character into the inline node.
      var startBlock = state.startBlock;

      var previousBlock = document.getClosestBlock(previous.key);
      var previousInline = document.getClosestInline(previous.key);

      if (previousBlock === startBlock && previousInline && !previousInline.isVoid) {
        var extendOrMove = e.shiftKey ? 'extend' : 'move';
        change.collapseToEndOf(previous)[extendOrMove](-1);
        return;
      }

      // Otherwise, move to the end of the previous node.
      change.collapseToEndOf(previous);
    }
  }

  /**
   * On `right` key down, move forward.
   *
   * COMPAT: This is required to make navigating with the right arrow work when
   * a void node is selected.
   *
   * COMPAT: This is also required to solve for the case where an inline node is
   * surrounded by empty text nodes with zero-width spaces in them. Without this
   * the zero-width spaces will cause two arrow keys to jump to the next text.
   *
   * COMPAT: In Chrome & Safari, selections that are at the zero offset of
   * an inline node will be automatically replaced to be at the last offset
   * of a previous inline node, which screws us up, so we never want to set the
   * selection to the very start of an inline node here. (2016/11/29)
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownRight(e, data, change) {
    var state = change.state;


    if (e.ctrlKey) return;
    if (e.altKey) return;
    if (state.isExpanded) return;

    var document = state.document,
        startKey = state.startKey,
        startText = state.startText;

    var hasVoidParent = document.hasVoidParent(startKey);

    // If the current text node is empty, or we're inside a void parent, we're
    // going to need to handle the selection behavior.
    if (startText.text == '' || hasVoidParent) {
      e.preventDefault();
      var next = document.getNextText(startKey);

      // If there's no next text node in the document, abort.
      if (!next) return;

      // If the next text is inside a void node, move to the end of it.
      if (document.hasVoidParent(next.key)) {
        change.collapseToEndOf(next);
        return;
      }

      // If the next text is in the current block, and inside an inline node,
      // move one character into the inline node.
      var startBlock = state.startBlock;

      var nextBlock = document.getClosestBlock(next.key);
      var nextInline = document.getClosestInline(next.key);

      if (nextBlock == startBlock && nextInline) {
        var extendOrMove = e.shiftKey ? 'extend' : 'move';
        change.collapseToStartOf(next)[extendOrMove](1);
        return;
      }

      // Otherwise, move to the start of the next text node.
      change.collapseToStartOf(next);
    }
  }

  /**
   * On `up` key down, for Macs, move the selection to start of the block.
   *
   * COMPAT: Certain browsers don't handle the selection updates properly. In
   * Chrome, option-shift-up doesn't properly extend the selection. And in
   * Firefox, option-up doesn't properly move the selection.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownUp(e, data, change) {
    if (!_environment.IS_MAC || e.ctrlKey || !e.altKey) return;

    var state = change.state;
    var selection = state.selection,
        document = state.document,
        focusKey = state.focusKey,
        focusBlock = state.focusBlock;

    var transform = e.shiftKey ? 'extendToStartOf' : 'collapseToStartOf';
    var block = selection.hasFocusAtStartOf(focusBlock) ? document.getPreviousBlock(focusKey) : focusBlock;

    if (!block) return;
    var text = block.getFirstText();

    e.preventDefault();
    change[transform](text);
  }

  /**
   * On `down` key down, for Macs, move the selection to end of the block.
   *
   * COMPAT: Certain browsers don't handle the selection updates properly. In
   * Chrome, option-shift-down doesn't properly extend the selection. And in
   * Firefox, option-down doesn't properly move the selection.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownDown(e, data, change) {
    if (!_environment.IS_MAC || e.ctrlKey || !e.altKey) return;

    var state = change.state;
    var selection = state.selection,
        document = state.document,
        focusKey = state.focusKey,
        focusBlock = state.focusBlock;

    var transform = e.shiftKey ? 'extendToEndOf' : 'collapseToEndOf';
    var block = selection.hasFocusAtEndOf(focusBlock) ? document.getNextBlock(focusKey) : focusBlock;

    if (!block) return;
    var text = block.getLastText();

    e.preventDefault();
    change[transform](text);
  }

  /**
   * On `d` key down, for Macs, delete one character forward.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownD(e, data, change) {
    if (!_environment.IS_MAC || !e.ctrlKey || e.altKey) return;
    e.preventDefault();
    change.deleteCharForward();
  }

  /**
   * On `h` key down, for Macs, delete until the end of the line.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownH(e, data, change) {
    if (!_environment.IS_MAC || !e.ctrlKey || e.altKey) return;
    e.preventDefault();
    change.deleteCharBackward();
  }

  /**
   * On `k` key down, for Macs, delete until the end of the line.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownK(e, data, change) {
    if (!_environment.IS_MAC || !e.ctrlKey || e.altKey) return;
    e.preventDefault();
    change.deleteLineForward();
  }

  /**
   * On `y` key down, redo.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownY(e, data, change) {
    var modKey = _environment.IS_MAC ? e.metaKey : e.ctrlKey;
    if (!modKey) return;
    change.redo();
  }

  /**
   * On `z` key down, undo or redo.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onKeyDownZ(e, data, change) {
    var modKey = _environment.IS_MAC ? e.metaKey : e.ctrlKey;
    if (!modKey) return;
    change[e.shiftKey ? 'redo' : 'undo']();
  }

  /**
   * On paste.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onPaste(e, data, change) {
    debug('onPaste', { data: data });

    switch (data.type) {
      case 'fragment':
        return onPasteFragment(e, data, change);
      case 'text':
      case 'html':
        return onPasteText(e, data, change);
    }
  }

  /**
   * On paste fragment.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onPasteFragment(e, data, change) {
    debug('onPasteFragment', { data: data });
    change.insertFragment(data.fragment);
  }

  /**
   * On paste text, split blocks at new lines.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onPasteText(e, data, change) {
    debug('onPasteText', { data: data });

    var state = change.state;
    var document = state.document,
        selection = state.selection,
        startBlock = state.startBlock;

    if (startBlock.isVoid) return;

    var text = data.text;

    var defaultBlock = startBlock;
    var defaultMarks = document.getMarksAtRange(selection.collapseToStart());
    var fragment = _slatePlainSerializer2.default.deserialize(text, { defaultBlock: defaultBlock, defaultMarks: defaultMarks }).document;
    change.insertFragment(fragment);
  }

  /**
   * On select.
   *
   * @param {Event} e
   * @param {Object} data
   * @param {Change} change
   */

  function onSelect(e, data, change) {
    debug('onSelect', { data: data });
    change.select(data.selection);
  }

  /**
   * Render.
   *
   * @param {Object} props
   * @param {State} state
   * @param {Editor} editor
   * @return {Object}
   */

  function render(props, state, editor) {
    return _react2.default.createElement(_content2.default, {
      autoCorrect: props.autoCorrect,
      autoFocus: props.autoFocus,
      className: props.className,
      children: props.children,
      editor: editor,
      onBeforeInput: editor.onBeforeInput,
      onBlur: editor.onBlur,
      onFocus: editor.onFocus,
      onCopy: editor.onCopy,
      onCut: editor.onCut,
      onDrop: editor.onDrop,
      onKeyDown: editor.onKeyDown,
      onKeyUp: editor.onKeyUp,
      onPaste: editor.onPaste,
      onSelect: editor.onSelect,
      readOnly: props.readOnly,
      role: props.role,
      schema: editor.getSchema(),
      spellCheck: props.spellCheck,
      state: state,
      style: props.style,
      tabIndex: props.tabIndex,
      tagName: props.tagName
    });
  }

  /**
   * A default schema rule to render block nodes.
   *
   * @type {Object}
   */

  var BLOCK_RENDER_RULE = {
    match: function match(node) {
      return node.kind == 'block';
    },
    render: function render(props) {
      return _react2.default.createElement(
        'div',
        _extends({}, props.attributes, { style: { position: 'relative' } }),
        props.children,
        placeholder ? _react2.default.createElement(
          _placeholder2.default,
          {
            className: placeholderClassName,
            node: props.node,
            parent: props.state.document,
            state: props.state,
            style: placeholderStyle
          },
          placeholder
        ) : null
      );
    }
  };

  /**
   * A default schema rule to render inline nodes.
   *
   * @type {Object}
   */

  var INLINE_RENDER_RULE = {
    match: function match(node) {
      return node.kind == 'inline';
    },
    render: function render(props) {
      return _react2.default.createElement(
        'span',
        _extends({}, props.attributes, { style: { position: 'relative' } }),
        props.children
      );
    }
  };

  /**
   * Add default rendering rules to the schema.
   *
   * @type {Object}
   */

  var schema = {
    rules: [BLOCK_RENDER_RULE, INLINE_RENDER_RULE]
  };

  /**
   * Return the core plugin.
   *
   * @type {Object}
   */

  return {
    onBeforeChange: onBeforeChange,
    onBeforeInput: onBeforeInput,
    onBlur: onBlur,
    onCopy: onCopy,
    onCut: onCut,
    onDrop: onDrop,
    onKeyDown: onKeyDown,
    onPaste: onPaste,
    onSelect: onSelect,
    render: render,
    schema: schema
  };
}

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Plugin;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wbHVnaW5zL2NvcmUuanMiXSwibmFtZXMiOlsiZGVidWciLCJQbHVnaW4iLCJvcHRpb25zIiwicGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlckNsYXNzTmFtZSIsInBsYWNlaG9sZGVyU3R5bGUiLCJvbkJlZm9yZUNoYW5nZSIsImNoYW5nZSIsImVkaXRvciIsInN0YXRlIiwic2NoZW1hIiwiZ2V0U2NoZW1hIiwicHJldlN0YXRlIiwiZ2V0U3RhdGUiLCJkb2N1bWVudCIsIm5vcm1hbGl6ZSIsIm9uQmVmb3JlSW5wdXQiLCJlIiwiZGF0YSIsImJlZm9yZWlucHV0IiwicHJldmVudERlZmF1bHQiLCJpbnNlcnRUZXh0Iiwib25CbHVyIiwiYmx1ciIsIm9uQ29weSIsIm9uQ3V0T3JDb3B5Iiwib25DdXQiLCJ3aW5kb3ciLCJ0YXJnZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0IiwiZGVsZXRlIiwibmF0aXZlIiwiZ2V0U2VsZWN0aW9uIiwic3RhcnRLZXkiLCJlbmRLZXkiLCJzdGFydFRleHQiLCJlbmRCbG9jayIsImVuZElubGluZSIsImlzVm9pZEJsb2NrIiwiaXNWb2lkIiwiaXNWb2lkSW5saW5lIiwiaXNDb2xsYXBzZWQiLCJmcmFnbWVudCIsImVuY29kZWQiLCJzZXJpYWxpemVOb2RlIiwicmFuZ2UiLCJnZXRSYW5nZUF0IiwiY29udGVudHMiLCJjbG9uZUNvbnRlbnRzIiwiYXR0YWNoIiwiY2hpbGROb2RlcyIsInIiLCJjbG9uZVJhbmdlIiwibiIsIm5vZGUiLCJzZXRFbmRBZnRlciIsImxlbmd0aCIsImZpcnN0Q2hpbGQiLCJoYXNNYXJrcyIsImNoYXJhY3RlcnMiLCJzbGljZSIsInNlbGVjdGlvbiIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiZmlsdGVyIiwiY2hhciIsIm1hcmtzIiwic2l6ZSIsInNldFN0YXJ0QmVmb3JlIiwiendzIiwiY2FsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwienciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbHMiLCJlbCIsInJlbW92ZUF0dHJpYnV0ZSIsIm5vZGVUeXBlIiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsIndoaXRlU3BhY2UiLCJhcHBlbmRDaGlsZCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJxdWVyeVNlbGVjdG9yIiwiZGl2IiwicG9zaXRpb24iLCJsZWZ0IiwiY3JlYXRlUmFuZ2UiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsIm9uRHJvcCIsInR5cGUiLCJvbkRyb3BUZXh0Iiwib25Ecm9wRnJhZ21lbnQiLCJvbkRyb3BOb2RlIiwiaXNJbnRlcm5hbCIsImVuZE9mZnNldCIsIm1vdmUiLCJzdGFydE9mZnNldCIsImlzQmxvY2siLCJzZWxlY3QiLCJmb2N1cyIsImluc2VydEJsb2NrIiwicmVtb3ZlTm9kZUJ5S2V5Iiwia2V5IiwiaXNJbmxpbmUiLCJpbnNlcnRJbmxpbmUiLCJpbnNlcnRGcmFnbWVudCIsInRleHQiLCJhbmNob3JLZXkiLCJoYXNWb2lkUGFyZW50IiwiZ2V0Tm9kZSIsImdldE5leHRUZXh0IiwiY29sbGFwc2VUb1N0YXJ0T2YiLCJzcGxpdCIsImxpbmUiLCJpIiwic3BsaXRCbG9jayIsIm9uS2V5RG93biIsIm9uS2V5RG93bkVudGVyIiwib25LZXlEb3duQmFja3NwYWNlIiwib25LZXlEb3duRGVsZXRlIiwib25LZXlEb3duTGVmdCIsIm9uS2V5RG93blJpZ2h0Iiwib25LZXlEb3duVXAiLCJvbktleURvd25Eb3duIiwib25LZXlEb3duRCIsIm9uS2V5RG93bkgiLCJvbktleURvd25LIiwib25LZXlEb3duWSIsIm9uS2V5RG93bloiLCJpc1dvcmQiLCJhbHRLZXkiLCJjdHJsS2V5IiwiaXNMaW5lIiwibWV0YUtleSIsImJvdW5kYXJ5IiwiaXNFeHBhbmRlZCIsInByZXZpb3VzIiwiZ2V0UHJldmlvdXNUZXh0Iiwic3RhcnRCbG9jayIsInByZXZpb3VzQmxvY2siLCJnZXRDbG9zZXN0QmxvY2siLCJwcmV2aW91c0lubGluZSIsImdldENsb3Nlc3RJbmxpbmUiLCJleHRlbmRPck1vdmUiLCJzaGlmdEtleSIsImNvbGxhcHNlVG9FbmRPZiIsIm5leHQiLCJuZXh0QmxvY2siLCJuZXh0SW5saW5lIiwiZm9jdXNLZXkiLCJmb2N1c0Jsb2NrIiwidHJhbnNmb3JtIiwiYmxvY2siLCJoYXNGb2N1c0F0U3RhcnRPZiIsImdldFByZXZpb3VzQmxvY2siLCJnZXRGaXJzdFRleHQiLCJoYXNGb2N1c0F0RW5kT2YiLCJnZXROZXh0QmxvY2siLCJnZXRMYXN0VGV4dCIsImRlbGV0ZUNoYXJGb3J3YXJkIiwiZGVsZXRlQ2hhckJhY2t3YXJkIiwiZGVsZXRlTGluZUZvcndhcmQiLCJtb2RLZXkiLCJyZWRvIiwib25QYXN0ZSIsIm9uUGFzdGVGcmFnbWVudCIsIm9uUGFzdGVUZXh0IiwiZGVmYXVsdEJsb2NrIiwiZGVmYXVsdE1hcmtzIiwiZ2V0TWFya3NBdFJhbmdlIiwiY29sbGFwc2VUb1N0YXJ0IiwiZGVzZXJpYWxpemUiLCJvblNlbGVjdCIsInJlbmRlciIsInByb3BzIiwiYXV0b0NvcnJlY3QiLCJhdXRvRm9jdXMiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsIm9uRm9jdXMiLCJvbktleVVwIiwicmVhZE9ubHkiLCJyb2xlIiwic3BlbGxDaGVjayIsInRhYkluZGV4IiwidGFnTmFtZSIsIkJMT0NLX1JFTkRFUl9SVUxFIiwibWF0Y2giLCJraW5kIiwiYXR0cmlidXRlcyIsIklOTElORV9SRU5ERVJfUlVMRSIsInJ1bGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxRQUFRLHFCQUFNLFlBQU4sQ0FBZDs7QUFFQTs7Ozs7Ozs7OztBQVVBLFNBQVNDLE1BQVQsR0FBOEI7QUFBQSxNQUFkQyxPQUFjLHVFQUFKLEVB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IiwiZmlsZSI6ImNvcmUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBCYXNlNjQgZnJvbSAnc2xhdGUtYmFzZTY0LXNlcmlhbGl6ZXInXG5pbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnXG5pbXBvcnQgUGxhaW4gZnJvbSAnc2xhdGUtcGxhaW4tc2VyaWFsaXplcidcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnZ2V0LXdpbmRvdydcbmltcG9ydCB7IEJsb2NrLCBJbmxpbmUsIGNvcmVTY2hlbWEgfSBmcm9tICdzbGF0ZSdcblxuaW1wb3J0IENvbnRlbnQgZnJvbSAnLi4vY29tcG9uZW50cy9jb250ZW50J1xuaW1wb3J0IFBsYWNlaG9sZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvcGxhY2Vob2xkZXInXG5pbXBvcnQgZmluZERPTU5vZGUgZnJvbSAnLi4vdXRpbHMvZmluZC1kb20tbm9kZSdcbmltcG9ydCB7IElTX0NIUk9NRSwgSVNfTUFDLCBJU19TQUZBUkksIFNVUFBPUlRFRF9FVkVOVFMgfSBmcm9tICcuLi9jb25zdGFudHMvZW52aXJvbm1lbnQnXG5cbi8qKlxuICogRGVidWcuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ3NsYXRlOmNvcmUnKVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBAcHJvcGVydHkge0VsZW1lbnR9IHBsYWNlaG9sZGVyXG4gKiAgIEBwcm9wZXJ0eSB7U3RyaW5nfSBwbGFjZWhvbGRlckNsYXNzTmFtZVxuICogICBAcHJvcGVydHkge09iamVjdH0gcGxhY2Vob2xkZXJTdHlsZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIFBsdWdpbihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVyQ2xhc3NOYW1lLFxuICAgIHBsYWNlaG9sZGVyU3R5bGUsXG4gIH0gPSBvcHRpb25zXG5cbiAgLyoqXG4gICAqIE9uIGJlZm9yZSBjaGFuZ2UsIGVuZm9yY2UgdGhlIGVkaXRvcidzIHNjaGVtYS5cbiAgICpcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKiBAcGFyYW0ge0VkaXRvcn0gc2NoZW1hXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQmVmb3JlQ2hhbmdlKGNoYW5nZSwgZWRpdG9yKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3Qgc2NoZW1hID0gZWRpdG9yLmdldFNjaGVtYSgpXG4gICAgY29uc3QgcHJldlN0YXRlID0gZWRpdG9yLmdldFN0YXRlKClcblxuICAgIC8vIFBFUkY6IFNraXAgbm9ybWFsaXppbmcgaWYgdGhlIGRvY3VtZW50IGhhc24ndCBjaGFuZ2VkLCBzaW5jZSBzY2hlbWFzIG9ubHlcbiAgICAvLyBub3JtYWxpemUgY2hhbmdlcyB0byB0aGUgZG9jdW1lbnQsIG5vdCBzZWxlY3Rpb24uXG4gICAgaWYgKHByZXZTdGF0ZSAmJiBzdGF0ZS5kb2N1bWVudCA9PSBwcmV2U3RhdGUuZG9jdW1lbnQpIHJldHVyblxuXG4gICAgY2hhbmdlLm5vcm1hbGl6ZShjb3JlU2NoZW1hKVxuICAgIGNoYW5nZS5ub3JtYWxpemUoc2NoZW1hKVxuICAgIGRlYnVnKCdvbkJlZm9yZUNoYW5nZScpXG4gIH1cblxuICAvKipcbiAgICogT24gYmVmb3JlIGlucHV0LCBjb3JyZWN0IGFueSBicm93c2VyIGluY29uc2lzdGVuY2llcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQmVmb3JlSW5wdXQoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uQmVmb3JlSW5wdXQnLCB7IGRhdGEgfSlcblxuICAgIC8vIFJlYWN0J3MgYG9uQmVmb3JlSW5wdXRgIHN5bnRoZXRpYyBldmVudCBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGBrZXlwcmVzc2BcbiAgICAvLyBhbmQgYHRleHRJbnB1dGAgZXZlbnRzLiBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgdGhlIG5hdGl2ZSBgYmVmb3JlaW5wdXRgXG4gICAgLy8gZXZlbnQsIHdlIGluc3RlYWQgdXNlIHRoYXQgZXZlbnQgdG8gdHJpZ2dlciB0ZXh0IGluc2VydGlvbiwgc2luY2UgaXRcbiAgICAvLyBwcm92aWRlcyBtb3JlIHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmFuZ2UgYmVpbmcgYWZmZWN0ZWQgYW5kIGFsc29cbiAgICAvLyBwcmVzZXJ2ZXMgY29tcGF0aWJpbGl0eSB3aXRoIGlPUyBhdXRvY29ycmVjdCwgd2hpY2ggd291bGQgYmUgYnJva2VuIGlmIHdlXG4gICAgLy8gY2FsbGVkIGBwcmV2ZW50RGVmYXVsdCgpYCBvbiBSZWFjdCdzIHN5bnRoZXRpYyBldmVudCBoZXJlLlxuICAgIGlmIChTVVBQT1JURURfRVZFTlRTLmJlZm9yZWlucHV0KSByZXR1cm5cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNoYW5nZS5pbnNlcnRUZXh0KGUuZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBibHVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25CbHVyKGUsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkJsdXInLCB7IGRhdGEgfSlcbiAgICBjaGFuZ2UuYmx1cigpXG4gIH1cblxuICAvKipcbiAgICogT24gY29weS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQ29weShlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25Db3B5JywgZGF0YSlcbiAgICBvbkN1dE9yQ29weShlLCBkYXRhLCBjaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogT24gY3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvclxuICAgKi9cblxuICBmdW5jdGlvbiBvbkN1dChlLCBkYXRhLCBjaGFuZ2UsIGVkaXRvcikge1xuICAgIGRlYnVnKCdvbkN1dCcsIGRhdGEpXG4gICAgb25DdXRPckNvcHkoZSwgZGF0YSwgY2hhbmdlKVxuICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlLnRhcmdldClcblxuICAgIC8vIE9uY2UgdGhlIGZha2UgY3V0IGNvbnRlbnQgaGFzIHN1Y2Nlc3NmdWxseSBiZWVuIGFkZGVkIHRvIHRoZSBjbGlwYm9hcmQsXG4gICAgLy8gZGVsZXRlIHRoZSBjb250ZW50IGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGVkaXRvci5jaGFuZ2UodCA9PiB0LmRlbGV0ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogT24gY3V0IG9yIGNvcHksIGNyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2UgNjRcbiAgICogZW5jb2RlZCBjb3B5IG9mIHRoZSBmcmFnbWVudCB0byB0aGUgSFRNTCwgdG8gZGVjb2RlIG9uIGZ1dHVyZSBwYXN0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkN1dE9yQ29weShlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZS50YXJnZXQpXG4gICAgY29uc3QgbmF0aXZlID0gd2luZG93LmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBzdGFydEtleSwgZW5kS2V5LCBzdGFydFRleHQsIGVuZEJsb2NrLCBlbmRJbmxpbmUgfSA9IHN0YXRlXG4gICAgY29uc3QgaXNWb2lkQmxvY2sgPSBlbmRCbG9jayAmJiBlbmRCbG9jay5pc1ZvaWRcbiAgICBjb25zdCBpc1ZvaWRJbmxpbmUgPSBlbmRJbmxpbmUgJiYgZW5kSW5saW5lLmlzVm9pZFxuICAgIGNvbnN0IGlzVm9pZCA9IGlzVm9pZEJsb2NrIHx8IGlzVm9pZElubGluZVxuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQsIGFuZCBpdCBpc24ndCBpbnNpZGUgYSB2b2lkIG5vZGUsIGFib3J0LlxuICAgIGlmIChuYXRpdmUuaXNDb2xsYXBzZWQgJiYgIWlzVm9pZCkgcmV0dXJuXG5cbiAgICBjb25zdCB7IGZyYWdtZW50IH0gPSBkYXRhXG4gICAgY29uc3QgZW5jb2RlZCA9IEJhc2U2NC5zZXJpYWxpemVOb2RlKGZyYWdtZW50KVxuICAgIGNvbnN0IHJhbmdlID0gbmF0aXZlLmdldFJhbmdlQXQoMClcbiAgICBsZXQgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKClcbiAgICBsZXQgYXR0YWNoID0gY29udGVudHMuY2hpbGROb2Rlc1swXVxuXG4gICAgLy8gSWYgdGhlIGVuZCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIGVuZCBvZiB0aGUgcmFuZ2UgZnJvbVxuICAgIC8vIHRoZSB2b2lkIG5vZGUncyBzcGFjZXIgc3BhbiwgdG8gdGhlIGVuZCBvZiB0aGUgdm9pZCBub2RlJ3MgY29udGVudC5cbiAgICBpZiAoaXNWb2lkKSB7XG4gICAgICBjb25zdCByID0gcmFuZ2UuY2xvbmVSYW5nZSgpXG4gICAgICBjb25zdCBuID0gaXNWb2lkQmxvY2sgPyBlbmRCbG9jayA6IGVuZElubGluZVxuICAgICAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKG4pXG4gICAgICByLnNldEVuZEFmdGVyKG5vZGUpXG4gICAgICBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpXG4gICAgICBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzW2NvbnRlbnRzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMV0uZmlyc3RDaGlsZFxuICAgIH1cblxuICAgIC8vIENPTVBBVDogaW4gU2FmYXJpIGFuZCBDaHJvbWUgd2hlbiBzZWxlY3RpbmcgYSBzaW5nbGUgbWFya2VkIHdvcmQsXG4gICAgLy8gbWFya3MgYXJlIG5vdCBwcmVzZXJ2ZWQgd2hlbiBjb3B5aW5nLlxuICAgIC8vIElmIHRoZSBhdHRhdGNoZWQgaXMgbm90IHZvaWQsIGFuZCB0aGUgc3RhcnRLZXkgYW5kIGVuZEtleSBpcyB0aGUgc2FtZSxcbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBtYXJrcyBpbnZvbHZlZC4gSWYgc28sIHNldCB0aGUgcmFuZ2Ugc3RhcnQganVzdCBiZWZvcmUgdGhlXG4gICAgLy8gc3RhcnRUZXh0IG5vZGVcbiAgICBpZiAoKElTX0NIUk9NRSB8fCBJU19TQUZBUkkpICYmICFpc1ZvaWQgJiYgc3RhcnRLZXkgPT09IGVuZEtleSkge1xuICAgICAgY29uc3QgaGFzTWFya3MgPSBzdGFydFRleHQuY2hhcmFjdGVyc1xuICAgICAgICAuc2xpY2Uoc3RhdGUuc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc3RhdGUuc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KVxuICAgICAgICAuZmlsdGVyKGNoYXIgPT4gY2hhci5tYXJrcy5zaXplICE9PSAwKVxuICAgICAgICAuc2l6ZSAhPT0gMFxuICAgICAgaWYgKGhhc01hcmtzKSB7XG4gICAgICAgIGNvbnN0IHIgPSByYW5nZS5jbG9uZVJhbmdlKClcbiAgICAgICAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKHN0YXJ0VGV4dClcbiAgICAgICAgci5zZXRTdGFydEJlZm9yZShub2RlKVxuICAgICAgICBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpXG4gICAgICAgIGF0dGFjaCA9IGNvbnRlbnRzLmNoaWxkTm9kZXNbY29udGVudHMuY2hpbGROb2Rlcy5sZW5ndGggLSAxXS5maXJzdENoaWxkXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSB6ZXJvLXdpZHRoIHNwYWNlIHNwYW5zIGZyb20gdGhlIGNsb25lZCBET00gc28gdGhhdCB0aGV5IGRvbid0XG4gICAgLy8gc2hvdyB1cCBlbHNld2hlcmUgd2hlbiBwYXN0ZWQuXG4gICAgY29uc3QgendzID0gW10uc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpKVxuICAgIHp3cy5mb3JFYWNoKHp3ID0+IHp3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoencpKVxuXG4gICAgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgc2VsZWN0aW9uIHRvXG4gICAgLy8gY29weSBoYXMgYGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJgIHRoZSBjb3B5IHdpbGwgZmFpbCwgYW5kIG5vdGhpbmcgd2lsbFxuICAgIC8vIGJlIHB1dCBpbiB0aGUgY2xpcGJvYXJkLiBTbyB3ZSByZW1vdmUgdGhlbSBhbGwuICgyMDE3LzA1LzA0KVxuICAgIGlmIChJU19DSFJPTUUgfHwgSVNfU0FGQVJJKSB7XG4gICAgICBjb25zdCBlbHMgPSBbXS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScpKVxuICAgICAgZWxzLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSlcbiAgICB9XG5cbiAgICAvLyBTZXQgYSBgZGF0YS1zbGF0ZS1mcmFnbWVudGAgYXR0cmlidXRlIG9uIGEgbm9uLWVtcHR5IG5vZGUsIHNvIGl0IHNob3dzIHVwXG4gICAgLy8gaW4gdGhlIEhUTUwsIGFuZCBjYW4gYmUgdXNlZCBmb3IgaW50cmEtU2xhdGUgcGFzdGluZy4gSWYgaXQncyBhIHRleHRcbiAgICAvLyBub2RlLCB3cmFwIGl0IGluIGEgYDxzcGFuPmAgc28gd2UgaGF2ZSBzb21ldGhpbmcgdG8gc2V0IGFuIGF0dHJpYnV0ZSBvbi5cbiAgICBpZiAoYXR0YWNoLm5vZGVUeXBlID09IDMpIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG5cbiAgICAgIC8vIENPTVBBVDogSW4gQ2hyb21lIGFuZCBTYWZhcmksIGlmIHdlIGRvbid0IGFkZCB0aGUgYHdoaXRlLXNwYWNlYCBzdHlsZVxuICAgICAgLy8gdGhlbiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMgd2lsbCBiZSBpZ25vcmVkLiAoMjAxNy8wOS8yMSlcbiAgICAgIHNwYW4uc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUnXG5cbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYXR0YWNoKVxuICAgICAgY29udGVudHMuYXBwZW5kQ2hpbGQoc3BhbilcbiAgICAgIGF0dGFjaCA9IHNwYW5cbiAgICB9XG5cbiAgICBhdHRhY2guc2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLWZyYWdtZW50JywgZW5jb2RlZClcblxuICAgIC8vIEFkZCB0aGUgcGhvbnkgY29udGVudCB0byB0aGUgRE9NLCBhbmQgc2VsZWN0IGl0LCBzbyBpdCB3aWxsIGJlIGNvcGllZC5cbiAgICBjb25zdCBib2R5ID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKVxuICAgIGNvbnN0IGRpdiA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpXG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIGRpdi5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnXG4gICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKVxuICAgIGJvZHkuYXBwZW5kQ2hpbGQoZGl2KVxuXG4gICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCB0cnlpbmcgdG8gdXNlIHRoZSB0ZXJzZXIgYG5hdGl2ZS5zZWxlY3RBbGxDaGlsZHJlbmBcbiAgICAvLyB0aHJvd3MgYW4gZXJyb3IsIHNvIHdlIHVzZSB0aGUgb2xkZXIgYHJhbmdlYCBlcXVpdmFsZW50LiAoMjAxNi8wNi8yMSlcbiAgICBjb25zdCByID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZVJhbmdlKClcbiAgICByLnNlbGVjdE5vZGVDb250ZW50cyhkaXYpXG4gICAgbmF0aXZlLnJlbW92ZUFsbFJhbmdlcygpXG4gICAgbmF0aXZlLmFkZFJhbmdlKHIpXG5cbiAgICAvLyBSZXZlcnQgdG8gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiByaWdodCBhZnRlciBjb3B5aW5nLlxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgYm9keS5yZW1vdmVDaGlsZChkaXYpXG4gICAgICBuYXRpdmUucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICAgIG5hdGl2ZS5hZGRSYW5nZShyYW5nZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRyb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRyb3AoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uRHJvcCcsIHsgZGF0YSB9KVxuXG4gICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiBvbkRyb3BUZXh0KGUsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ2ZyYWdtZW50JzpcbiAgICAgICAgcmV0dXJuIG9uRHJvcEZyYWdtZW50KGUsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ25vZGUnOlxuICAgICAgICByZXR1cm4gb25Ecm9wTm9kZShlLCBkYXRhLCBjaGFuZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRyb3Agbm9kZSwgaW5zZXJ0IHRoZSBub2RlIHdoZXJldmVyIGl0IGlzIGRyb3BwZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRyb3BOb2RlKGUsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvbkRyb3BOb2RlJywgeyBkYXRhIH0pXG5cbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBsZXQgeyBub2RlLCB0YXJnZXQsIGlzSW50ZXJuYWwgfSA9IGRhdGFcblxuICAgIC8vIElmIHRoZSBkcmFnIGlzIGludGVybmFsIGFuZCB0aGUgdGFyZ2V0IGlzIGFmdGVyIHRoZSBzZWxlY3Rpb24sIGl0XG4gICAgLy8gbmVlZHMgdG8gYWNjb3VudCBmb3IgdGhlIHNlbGVjdGlvbidzIGNvbnRlbnQgYmVpbmcgZGVsZXRlZC5cbiAgICBpZiAoXG4gICAgICBpc0ludGVybmFsICYmXG4gICAgICBzZWxlY3Rpb24uZW5kS2V5ID09IHRhcmdldC5lbmRLZXkgJiZcbiAgICAgIHNlbGVjdGlvbi5lbmRPZmZzZXQgPCB0YXJnZXQuZW5kT2Zmc2V0XG4gICAgKSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQubW92ZShzZWxlY3Rpb24uc3RhcnRLZXkgPT0gc2VsZWN0aW9uLmVuZEtleVxuICAgICAgICA/IDAgLSBzZWxlY3Rpb24uZW5kT2Zmc2V0ICsgc2VsZWN0aW9uLnN0YXJ0T2Zmc2V0XG4gICAgICAgIDogMCAtIHNlbGVjdGlvbi5lbmRPZmZzZXQpXG4gICAgfVxuXG4gICAgaWYgKGlzSW50ZXJuYWwpIHtcbiAgICAgIGNoYW5nZS5kZWxldGUoKVxuICAgIH1cblxuICAgIGlmIChCbG9jay5pc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBjaGFuZ2VcbiAgICAgICAgLnNlbGVjdCh0YXJnZXQpXG4gICAgICAgIC5mb2N1cygpXG4gICAgICAgIC5pbnNlcnRCbG9jayhub2RlKVxuICAgICAgICAucmVtb3ZlTm9kZUJ5S2V5KG5vZGUua2V5KVxuICAgIH1cblxuICAgIGlmIChJbmxpbmUuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgIGNoYW5nZVxuICAgICAgICAuc2VsZWN0KHRhcmdldClcbiAgICAgICAgLmZvY3VzKClcbiAgICAgICAgLmluc2VydElubGluZShub2RlKVxuICAgICAgICAucmVtb3ZlTm9kZUJ5S2V5KG5vZGUua2V5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkcm9wIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25Ecm9wRnJhZ21lbnQoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uRHJvcEZyYWdtZW50JywgeyBkYXRhIH0pXG5cbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICBsZXQgeyBmcmFnbWVudCwgdGFyZ2V0LCBpc0ludGVybmFsIH0gPSBkYXRhXG5cbiAgICAvLyBJZiB0aGUgZHJhZyBpcyBpbnRlcm5hbCBhbmQgdGhlIHRhcmdldCBpcyBhZnRlciB0aGUgc2VsZWN0aW9uLCBpdFxuICAgIC8vIG5lZWRzIHRvIGFjY291bnQgZm9yIHRoZSBzZWxlY3Rpb24ncyBjb250ZW50IGJlaW5nIGRlbGV0ZWQuXG4gICAgaWYgKFxuICAgICAgaXNJbnRlcm5hbCAmJlxuICAgICAgc2VsZWN0aW9uLmVuZEtleSA9PSB0YXJnZXQuZW5kS2V5ICYmXG4gICAgICBzZWxlY3Rpb24uZW5kT2Zmc2V0IDwgdGFyZ2V0LmVuZE9mZnNldFxuICAgICkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lm1vdmUoc2VsZWN0aW9uLnN0YXJ0S2V5ID09IHNlbGVjdGlvbi5lbmRLZXlcbiAgICAgICAgPyAwIC0gc2VsZWN0aW9uLmVuZE9mZnNldCArIHNlbGVjdGlvbi5zdGFydE9mZnNldFxuICAgICAgICA6IDAgLSBzZWxlY3Rpb24uZW5kT2Zmc2V0KVxuICAgIH1cblxuICAgIGlmIChpc0ludGVybmFsKSB7XG4gICAgICBjaGFuZ2UuZGVsZXRlKClcbiAgICB9XG5cbiAgICBjaGFuZ2VcbiAgICAgIC5zZWxlY3QodGFyZ2V0KVxuICAgICAgLmZvY3VzKClcbiAgICAgIC5pbnNlcnRGcmFnbWVudChmcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBkcm9wIHRleHQsIHNwbGl0IHRoZSBibG9ja3MgYXQgbmV3IGxpbmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25Ecm9wVGV4dChlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25Ecm9wVGV4dCcsIHsgZGF0YSB9KVxuXG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBkb2N1bWVudCB9ID0gc3RhdGVcbiAgICBjb25zdCB7IHRleHQsIHRhcmdldCB9ID0gZGF0YVxuICAgIGNvbnN0IHsgYW5jaG9yS2V5IH0gPSB0YXJnZXRcblxuICAgIGNoYW5nZS5zZWxlY3QodGFyZ2V0KS5mb2N1cygpXG5cbiAgICBsZXQgaGFzVm9pZFBhcmVudCA9IGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQoYW5jaG9yS2V5KVxuXG4gICAgLy8gSW5zZXJ0IHRleHQgaW50byBuZWFyZXN0IHRleHQgbm9kZVxuICAgIGlmIChoYXNWb2lkUGFyZW50KSB7XG4gICAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmdldE5vZGUoYW5jaG9yS2V5KVxuXG4gICAgICB3aGlsZSAoaGFzVm9pZFBhcmVudCkge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0TmV4dFRleHQobm9kZS5rZXkpXG4gICAgICAgIGlmICghbm9kZSkgYnJlYWtcbiAgICAgICAgaGFzVm9pZFBhcmVudCA9IGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQobm9kZS5rZXkpXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlKSBjaGFuZ2UuY29sbGFwc2VUb1N0YXJ0T2Yobm9kZSlcbiAgICB9XG5cbiAgICB0ZXh0XG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA+IDApIGNoYW5nZS5zcGxpdEJsb2NrKClcbiAgICAgICAgY2hhbmdlLmluc2VydFRleHQobGluZSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogT24ga2V5IGRvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd24oZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uS2V5RG93bicsIHsgZGF0YSB9KVxuXG4gICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgY2FzZSAnRW50ZXInOiByZXR1cm4gb25LZXlEb3duRW50ZXIoZSwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnQmFja3NwYWNlJzogcmV0dXJuIG9uS2V5RG93bkJhY2tzcGFjZShlLCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICdEZWxldGUnOiByZXR1cm4gb25LZXlEb3duRGVsZXRlKGUsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ0Fycm93TGVmdCc6IHJldHVybiBvbktleURvd25MZWZ0KGUsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOiByZXR1cm4gb25LZXlEb3duUmlnaHQoZSwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnQXJyb3dVcCc6IHJldHVybiBvbktleURvd25VcChlLCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICdBcnJvd0Rvd24nOiByZXR1cm4gb25LZXlEb3duRG93bihlLCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICdkJzogcmV0dXJuIG9uS2V5RG93bkQoZSwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAnaCc6IHJldHVybiBvbktleURvd25IKGUsIGRhdGEsIGNoYW5nZSlcbiAgICAgIGNhc2UgJ2snOiByZXR1cm4gb25LZXlEb3duSyhlLCBkYXRhLCBjaGFuZ2UpXG4gICAgICBjYXNlICd5JzogcmV0dXJuIG9uS2V5RG93blkoZSwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzogcmV0dXJuIG9uS2V5RG93blooZSwgZGF0YSwgY2hhbmdlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgZW50ZXJgIGtleSBkb3duLCBzcGxpdCB0aGUgY3VycmVudCBibG9jayBpbiBoYWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duRW50ZXIoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gICAgY29uc3QgeyBkb2N1bWVudCwgc3RhcnRLZXkgfSA9IHN0YXRlXG4gICAgY29uc3QgaGFzVm9pZFBhcmVudCA9IGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQoc3RhcnRLZXkpXG5cbiAgICAvLyBGb3Igdm9pZCBub2Rlcywgd2UgZG9uJ3Qgd2FudCB0byBzcGxpdC4gSW5zdGVhZCB3ZSBqdXN0IG1vdmUgdG8gdGhlIHN0YXJ0XG4gICAgLy8gb2YgdGhlIG5leHQgdGV4dCBub2RlIGlmIG9uZSBleGlzdHMuXG4gICAgaWYgKGhhc1ZvaWRQYXJlbnQpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5nZXROZXh0VGV4dChzdGFydEtleSlcbiAgICAgIGlmICghdGV4dCkgcmV0dXJuXG4gICAgICBjaGFuZ2UuY29sbGFwc2VUb1N0YXJ0T2YodGV4dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNoYW5nZS5zcGxpdEJsb2NrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgYmFja3NwYWNlYCBrZXkgZG93biwgZGVsZXRlIGJhY2t3YXJkcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bkJhY2tzcGFjZShlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCBpc1dvcmQgPSBJU19NQUMgPyBlLmFsdEtleSA6IGUuY3RybEtleVxuICAgIGNvbnN0IGlzTGluZSA9IElTX01BQyA/IGUubWV0YUtleSA6IGZhbHNlXG5cbiAgICBsZXQgYm91bmRhcnkgPSAnQ2hhcidcbiAgICBpZiAoaXNXb3JkKSBib3VuZGFyeSA9ICdXb3JkJ1xuICAgIGlmIChpc0xpbmUpIGJvdW5kYXJ5ID0gJ0xpbmUnXG5cbiAgICBjaGFuZ2VbYGRlbGV0ZSR7Ym91bmRhcnl9QmFja3dhcmRgXSgpXG4gIH1cblxuICAvKipcbiAgICogT24gYGRlbGV0ZWAga2V5IGRvd24sIGRlbGV0ZSBmb3J3YXJkcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bkRlbGV0ZShlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCBpc1dvcmQgPSBJU19NQUMgPyBlLmFsdEtleSA6IGUuY3RybEtleVxuICAgIGNvbnN0IGlzTGluZSA9IElTX01BQyA/IGUubWV0YUtleSA6IGZhbHNlXG5cbiAgICBsZXQgYm91bmRhcnkgPSAnQ2hhcidcbiAgICBpZiAoaXNXb3JkKSBib3VuZGFyeSA9ICdXb3JkJ1xuICAgIGlmIChpc0xpbmUpIGJvdW5kYXJ5ID0gJ0xpbmUnXG5cbiAgICBjaGFuZ2VbYGRlbGV0ZSR7Ym91bmRhcnl9Rm9yd2FyZGBdKClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgbGVmdGAga2V5IGRvd24sIG1vdmUgYmFja3dhcmQuXG4gICAqXG4gICAqIENPTVBBVDogVGhpcyBpcyByZXF1aXJlZCB0byBtYWtlIG5hdmlnYXRpbmcgd2l0aCB0aGUgbGVmdCBhcnJvdyB3b3JrIHdoZW5cbiAgICogYSB2b2lkIG5vZGUgaXMgc2VsZWN0ZWQuXG4gICAqXG4gICAqIENPTVBBVDogVGhpcyBpcyBhbHNvIHJlcXVpcmVkIHRvIHNvbHZlIGZvciB0aGUgY2FzZSB3aGVyZSBhbiBpbmxpbmUgbm9kZSBpc1xuICAgKiBzdXJyb3VuZGVkIGJ5IGVtcHR5IHRleHQgbm9kZXMgd2l0aCB6ZXJvLXdpZHRoIHNwYWNlcyBpbiB0aGVtLiBXaXRob3V0IHRoaXNcbiAgICogdGhlIHplcm8td2lkdGggc3BhY2VzIHdpbGwgY2F1c2UgdHdvIGFycm93IGtleXMgdG8ganVtcCB0byB0aGUgbmV4dCB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duTGVmdChlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcblxuICAgIGlmIChlLmN0cmxLZXkpIHJldHVyblxuICAgIGlmIChlLmFsdEtleSkgcmV0dXJuXG4gICAgaWYgKHN0YXRlLmlzRXhwYW5kZWQpIHJldHVyblxuXG4gICAgY29uc3QgeyBkb2N1bWVudCwgc3RhcnRLZXksIHN0YXJ0VGV4dCB9ID0gc3RhdGVcbiAgICBjb25zdCBoYXNWb2lkUGFyZW50ID0gZG9jdW1lbnQuaGFzVm9pZFBhcmVudChzdGFydEtleSlcblxuICAgIC8vIElmIHRoZSBjdXJyZW50IHRleHQgbm9kZSBpcyBlbXB0eSwgb3Igd2UncmUgaW5zaWRlIGEgdm9pZCBwYXJlbnQsIHdlJ3JlXG4gICAgLy8gZ29pbmcgdG8gbmVlZCB0byBoYW5kbGUgdGhlIHNlbGVjdGlvbiBiZWhhdmlvci5cbiAgICBpZiAoc3RhcnRUZXh0LnRleHQgPT0gJycgfHwgaGFzVm9pZFBhcmVudCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBjb25zdCBwcmV2aW91cyA9IGRvY3VtZW50LmdldFByZXZpb3VzVGV4dChzdGFydEtleSlcblxuICAgICAgLy8gSWYgdGhlcmUncyBubyBwcmV2aW91cyB0ZXh0IG5vZGUgaW4gdGhlIGRvY3VtZW50LCBhYm9ydC5cbiAgICAgIGlmICghcHJldmlvdXMpIHJldHVyblxuXG4gICAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGV4dCBpcyBpbiB0aGUgY3VycmVudCBibG9jaywgYW5kIGluc2lkZSBhIG5vbi12b2lkXG4gICAgICAvLyBpbmxpbmUgbm9kZSwgbW92ZSBvbmUgY2hhcmFjdGVyIGludG8gdGhlIGlubGluZSBub2RlLlxuICAgICAgY29uc3QgeyBzdGFydEJsb2NrIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgcHJldmlvdXNCbG9jayA9IGRvY3VtZW50LmdldENsb3Nlc3RCbG9jayhwcmV2aW91cy5rZXkpXG4gICAgICBjb25zdCBwcmV2aW91c0lubGluZSA9IGRvY3VtZW50LmdldENsb3Nlc3RJbmxpbmUocHJldmlvdXMua2V5KVxuXG4gICAgICBpZiAocHJldmlvdXNCbG9jayA9PT0gc3RhcnRCbG9jayAmJiBwcmV2aW91c0lubGluZSAmJiAhcHJldmlvdXNJbmxpbmUuaXNWb2lkKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE9yTW92ZSA9IGUuc2hpZnRLZXkgPyAnZXh0ZW5kJyA6ICdtb3ZlJ1xuICAgICAgICBjaGFuZ2UuY29sbGFwc2VUb0VuZE9mKHByZXZpb3VzKVtleHRlbmRPck1vdmVdKC0xKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBtb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG5vZGUuXG4gICAgICBjaGFuZ2UuY29sbGFwc2VUb0VuZE9mKHByZXZpb3VzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgcmlnaHRgIGtleSBkb3duLCBtb3ZlIGZvcndhcmQuXG4gICAqXG4gICAqIENPTVBBVDogVGhpcyBpcyByZXF1aXJlZCB0byBtYWtlIG5hdmlnYXRpbmcgd2l0aCB0aGUgcmlnaHQgYXJyb3cgd29yayB3aGVuXG4gICAqIGEgdm9pZCBub2RlIGlzIHNlbGVjdGVkLlxuICAgKlxuICAgKiBDT01QQVQ6IFRoaXMgaXMgYWxzbyByZXF1aXJlZCB0byBzb2x2ZSBmb3IgdGhlIGNhc2Ugd2hlcmUgYW4gaW5saW5lIG5vZGUgaXNcbiAgICogc3Vycm91bmRlZCBieSBlbXB0eSB0ZXh0IG5vZGVzIHdpdGggemVyby13aWR0aCBzcGFjZXMgaW4gdGhlbS4gV2l0aG91dCB0aGlzXG4gICAqIHRoZSB6ZXJvLXdpZHRoIHNwYWNlcyB3aWxsIGNhdXNlIHR3byBhcnJvdyBrZXlzIHRvIGp1bXAgdG8gdGhlIG5leHQgdGV4dC5cbiAgICpcbiAgICogQ09NUEFUOiBJbiBDaHJvbWUgJiBTYWZhcmksIHNlbGVjdGlvbnMgdGhhdCBhcmUgYXQgdGhlIHplcm8gb2Zmc2V0IG9mXG4gICAqIGFuIGlubGluZSBub2RlIHdpbGwgYmUgYXV0b21hdGljYWxseSByZXBsYWNlZCB0byBiZSBhdCB0aGUgbGFzdCBvZmZzZXRcbiAgICogb2YgYSBwcmV2aW91cyBpbmxpbmUgbm9kZSwgd2hpY2ggc2NyZXdzIHVzIHVwLCBzbyB3ZSBuZXZlciB3YW50IHRvIHNldCB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSB2ZXJ5IHN0YXJ0IG9mIGFuIGlubGluZSBub2RlIGhlcmUuICgyMDE2LzExLzI5KVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duUmlnaHQoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG5cbiAgICBpZiAoZS5jdHJsS2V5KSByZXR1cm5cbiAgICBpZiAoZS5hbHRLZXkpIHJldHVyblxuICAgIGlmIChzdGF0ZS5pc0V4cGFuZGVkKSByZXR1cm5cblxuICAgIGNvbnN0IHsgZG9jdW1lbnQsIHN0YXJ0S2V5LCBzdGFydFRleHQgfSA9IHN0YXRlXG4gICAgY29uc3QgaGFzVm9pZFBhcmVudCA9IGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQoc3RhcnRLZXkpXG5cbiAgICAvLyBJZiB0aGUgY3VycmVudCB0ZXh0IG5vZGUgaXMgZW1wdHksIG9yIHdlJ3JlIGluc2lkZSBhIHZvaWQgcGFyZW50LCB3ZSdyZVxuICAgIC8vIGdvaW5nIHRvIG5lZWQgdG8gaGFuZGxlIHRoZSBzZWxlY3Rpb24gYmVoYXZpb3IuXG4gICAgaWYgKHN0YXJ0VGV4dC50ZXh0ID09ICcnIHx8IGhhc1ZvaWRQYXJlbnQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgY29uc3QgbmV4dCA9IGRvY3VtZW50LmdldE5leHRUZXh0KHN0YXJ0S2V5KVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG5leHQgdGV4dCBub2RlIGluIHRoZSBkb2N1bWVudCwgYWJvcnQuXG4gICAgICBpZiAoIW5leHQpIHJldHVyblxuXG4gICAgICAvLyBJZiB0aGUgbmV4dCB0ZXh0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSB0byB0aGUgZW5kIG9mIGl0LlxuICAgICAgaWYgKGRvY3VtZW50Lmhhc1ZvaWRQYXJlbnQobmV4dC5rZXkpKSB7XG4gICAgICAgIGNoYW5nZS5jb2xsYXBzZVRvRW5kT2YobmV4dClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBuZXh0IHRleHQgaXMgaW4gdGhlIGN1cnJlbnQgYmxvY2ssIGFuZCBpbnNpZGUgYW4gaW5saW5lIG5vZGUsXG4gICAgICAvLyBtb3ZlIG9uZSBjaGFyYWN0ZXIgaW50byB0aGUgaW5saW5lIG5vZGUuXG4gICAgICBjb25zdCB7IHN0YXJ0QmxvY2sgfSA9IHN0YXRlXG4gICAgICBjb25zdCBuZXh0QmxvY2sgPSBkb2N1bWVudC5nZXRDbG9zZXN0QmxvY2sobmV4dC5rZXkpXG4gICAgICBjb25zdCBuZXh0SW5saW5lID0gZG9jdW1lbnQuZ2V0Q2xvc2VzdElubGluZShuZXh0LmtleSlcblxuICAgICAgaWYgKG5leHRCbG9jayA9PSBzdGFydEJsb2NrICYmIG5leHRJbmxpbmUpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kT3JNb3ZlID0gZS5zaGlmdEtleSA/ICdleHRlbmQnIDogJ21vdmUnXG4gICAgICAgIGNoYW5nZS5jb2xsYXBzZVRvU3RhcnRPZihuZXh0KVtleHRlbmRPck1vdmVdKDEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IHRleHQgbm9kZS5cbiAgICAgIGNoYW5nZS5jb2xsYXBzZVRvU3RhcnRPZihuZXh0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgdXBgIGtleSBkb3duLCBmb3IgTWFjcywgbW92ZSB0aGUgc2VsZWN0aW9uIHRvIHN0YXJ0IG9mIHRoZSBibG9jay5cbiAgICpcbiAgICogQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXMgcHJvcGVybHkuIEluXG4gICAqIENocm9tZSwgb3B0aW9uLXNoaWZ0LXVwIGRvZXNuJ3QgcHJvcGVybHkgZXh0ZW5kIHRoZSBzZWxlY3Rpb24uIEFuZCBpblxuICAgKiBGaXJlZm94LCBvcHRpb24tdXAgZG9lc24ndCBwcm9wZXJseSBtb3ZlIHRoZSBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd25VcChlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBpZiAoIUlTX01BQyB8fCBlLmN0cmxLZXkgfHwgIWUuYWx0S2V5KSByZXR1cm5cblxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2N1bWVudCwgZm9jdXNLZXksIGZvY3VzQmxvY2sgfSA9IHN0YXRlXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZS5zaGlmdEtleSA/ICdleHRlbmRUb1N0YXJ0T2YnIDogJ2NvbGxhcHNlVG9TdGFydE9mJ1xuICAgIGNvbnN0IGJsb2NrID0gc2VsZWN0aW9uLmhhc0ZvY3VzQXRTdGFydE9mKGZvY3VzQmxvY2spXG4gICAgICA/IGRvY3VtZW50LmdldFByZXZpb3VzQmxvY2soZm9jdXNLZXkpXG4gICAgICA6IGZvY3VzQmxvY2tcblxuICAgIGlmICghYmxvY2spIHJldHVyblxuICAgIGNvbnN0IHRleHQgPSBibG9jay5nZXRGaXJzdFRleHQoKVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2hhbmdlW3RyYW5zZm9ybV0odGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgZG93bmAga2V5IGRvd24sIGZvciBNYWNzLCBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gZW5kIG9mIHRoZSBibG9jay5cbiAgICpcbiAgICogQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXMgcHJvcGVybHkuIEluXG4gICAqIENocm9tZSwgb3B0aW9uLXNoaWZ0LWRvd24gZG9lc24ndCBwcm9wZXJseSBleHRlbmQgdGhlIHNlbGVjdGlvbi4gQW5kIGluXG4gICAqIEZpcmVmb3gsIG9wdGlvbi1kb3duIGRvZXNuJ3QgcHJvcGVybHkgbW92ZSB0aGUgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duRG93bihlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBpZiAoIUlTX01BQyB8fCBlLmN0cmxLZXkgfHwgIWUuYWx0S2V5KSByZXR1cm5cblxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2N1bWVudCwgZm9jdXNLZXksIGZvY3VzQmxvY2sgfSA9IHN0YXRlXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZS5zaGlmdEtleSA/ICdleHRlbmRUb0VuZE9mJyA6ICdjb2xsYXBzZVRvRW5kT2YnXG4gICAgY29uc3QgYmxvY2sgPSBzZWxlY3Rpb24uaGFzRm9jdXNBdEVuZE9mKGZvY3VzQmxvY2spXG4gICAgICA/IGRvY3VtZW50LmdldE5leHRCbG9jayhmb2N1c0tleSlcbiAgICAgIDogZm9jdXNCbG9ja1xuXG4gICAgaWYgKCFibG9jaykgcmV0dXJuXG4gICAgY29uc3QgdGV4dCA9IGJsb2NrLmdldExhc3RUZXh0KClcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNoYW5nZVt0cmFuc2Zvcm1dKHRleHQpXG4gIH1cblxuICAvKipcbiAgICogT24gYGRgIGtleSBkb3duLCBmb3IgTWFjcywgZGVsZXRlIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bkQoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFJU19NQUMgfHwgIWUuY3RybEtleSB8fCBlLmFsdEtleSkgcmV0dXJuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2hhbmdlLmRlbGV0ZUNoYXJGb3J3YXJkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBgaGAga2V5IGRvd24sIGZvciBNYWNzLCBkZWxldGUgdW50aWwgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bkgoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgaWYgKCFJU19NQUMgfHwgIWUuY3RybEtleSB8fCBlLmFsdEtleSkgcmV0dXJuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2hhbmdlLmRlbGV0ZUNoYXJCYWNrd2FyZCgpXG4gIH1cblxuICAvKipcbiAgICogT24gYGtgIGtleSBkb3duLCBmb3IgTWFjcywgZGVsZXRlIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvbktleURvd25LKGUsIGRhdGEsIGNoYW5nZSkge1xuICAgIGlmICghSVNfTUFDIHx8ICFlLmN0cmxLZXkgfHwgZS5hbHRLZXkpIHJldHVyblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGNoYW5nZS5kZWxldGVMaW5lRm9yd2FyZCgpXG4gIH1cblxuICAvKipcbiAgICogT24gYHlgIGtleSBkb3duLCByZWRvLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duWShlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCBtb2RLZXkgPSBJU19NQUMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXlcbiAgICBpZiAoIW1vZEtleSkgcmV0dXJuXG4gICAgY2hhbmdlLnJlZG8oKVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGB6YCBrZXkgZG93biwgdW5kbyBvciByZWRvLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEBwYXJhbSB7Q2hhbmdlfSBjaGFuZ2VcbiAgICovXG5cbiAgZnVuY3Rpb24gb25LZXlEb3duWihlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBjb25zdCBtb2RLZXkgPSBJU19NQUMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXlcbiAgICBpZiAoIW1vZEtleSkgcmV0dXJuXG4gICAgY2hhbmdlW2Uuc2hpZnRLZXkgPyAncmVkbycgOiAndW5kbyddKClcbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBwYXN0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uUGFzdGUoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uUGFzdGUnLCB7IGRhdGEgfSlcblxuICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICBjYXNlICdmcmFnbWVudCc6XG4gICAgICAgIHJldHVybiBvblBhc3RlRnJhZ21lbnQoZSwgZGF0YSwgY2hhbmdlKVxuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIG9uUGFzdGVUZXh0KGUsIGRhdGEsIGNoYW5nZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gcGFzdGUgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvblBhc3RlRnJhZ21lbnQoZSwgZGF0YSwgY2hhbmdlKSB7XG4gICAgZGVidWcoJ29uUGFzdGVGcmFnbWVudCcsIHsgZGF0YSB9KVxuICAgIGNoYW5nZS5pbnNlcnRGcmFnbWVudChkYXRhLmZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIHBhc3RlIHRleHQsIHNwbGl0IGJsb2NrcyBhdCBuZXcgbGluZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICAgKi9cblxuICBmdW5jdGlvbiBvblBhc3RlVGV4dChlLCBkYXRhLCBjaGFuZ2UpIHtcbiAgICBkZWJ1Zygnb25QYXN0ZVRleHQnLCB7IGRhdGEgfSlcblxuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICAgIGNvbnN0IHsgZG9jdW1lbnQsIHNlbGVjdGlvbiwgc3RhcnRCbG9jayB9ID0gc3RhdGVcbiAgICBpZiAoc3RhcnRCbG9jay5pc1ZvaWQpIHJldHVyblxuXG4gICAgY29uc3QgeyB0ZXh0IH0gPSBkYXRhXG4gICAgY29uc3QgZGVmYXVsdEJsb2NrID0gc3RhcnRCbG9ja1xuICAgIGNvbnN0IGRlZmF1bHRNYXJrcyA9IGRvY3VtZW50LmdldE1hcmtzQXRSYW5nZShzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCkpXG4gICAgY29uc3QgZnJhZ21lbnQgPSBQbGFpbi5kZXNlcmlhbGl6ZSh0ZXh0LCB7IGRlZmF1bHRCbG9jaywgZGVmYXVsdE1hcmtzIH0pLmRvY3VtZW50XG4gICAgY2hhbmdlLmluc2VydEZyYWdtZW50KGZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIHNlbGVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uU2VsZWN0KGUsIGRhdGEsIGNoYW5nZSkge1xuICAgIGRlYnVnKCdvblNlbGVjdCcsIHsgZGF0YSB9KVxuICAgIGNoYW5nZS5zZWxlY3QoZGF0YS5zZWxlY3Rpb24pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAgICogQHBhcmFtIHtFZGl0b3J9IGVkaXRvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbmRlcihwcm9wcywgc3RhdGUsIGVkaXRvcikge1xuICAgIHJldHVybiAoXG4gICAgICA8Q29udGVudFxuICAgICAgICBhdXRvQ29ycmVjdD17cHJvcHMuYXV0b0NvcnJlY3R9XG4gICAgICAgIGF1dG9Gb2N1cz17cHJvcHMuYXV0b0ZvY3VzfVxuICAgICAgICBjbGFzc05hbWU9e3Byb3BzLmNsYXNzTmFtZX1cbiAgICAgICAgY2hpbGRyZW49e3Byb3BzLmNoaWxkcmVufVxuICAgICAgICBlZGl0b3I9e2VkaXRvcn1cbiAgICAgICAgb25CZWZvcmVJbnB1dD17ZWRpdG9yLm9uQmVmb3JlSW5wdXR9XG4gICAgICAgIG9uQmx1cj17ZWRpdG9yLm9uQmx1cn1cbiAgICAgICAgb25Gb2N1cz17ZWRpdG9yLm9uRm9jdXN9XG4gICAgICAgIG9uQ29weT17ZWRpdG9yLm9uQ29weX1cbiAgICAgICAgb25DdXQ9e2VkaXRvci5vbkN1dH1cbiAgICAgICAgb25Ecm9wPXtlZGl0b3Iub25Ecm9wfVxuICAgICAgICBvbktleURvd249e2VkaXRvci5vbktleURvd259XG4gICAgICAgIG9uS2V5VXA9e2VkaXRvci5vbktleVVwfVxuICAgICAgICBvblBhc3RlPXtlZGl0b3Iub25QYXN0ZX1cbiAgICAgICAgb25TZWxlY3Q9e2VkaXRvci5vblNlbGVjdH1cbiAgICAgICAgcmVhZE9ubHk9e3Byb3BzLnJlYWRPbmx5fVxuICAgICAgICByb2xlPXtwcm9wcy5yb2xlfVxuICAgICAgICBzY2hlbWE9e2VkaXRvci5nZXRTY2hlbWEoKX1cbiAgICAgICAgc3BlbGxDaGVjaz17cHJvcHMuc3BlbGxDaGVja31cbiAgICAgICAgc3RhdGU9e3N0YXRlfVxuICAgICAgICBzdHlsZT17cHJvcHMuc3R5bGV9XG4gICAgICAgIHRhYkluZGV4PXtwcm9wcy50YWJJbmRleH1cbiAgICAgICAgdGFnTmFtZT17cHJvcHMudGFnTmFtZX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgZGVmYXVsdCBzY2hlbWEgcnVsZSB0byByZW5kZXIgYmxvY2sgbm9kZXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIGNvbnN0IEJMT0NLX1JFTkRFUl9SVUxFID0ge1xuICAgIG1hdGNoOiAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUua2luZCA9PSAnYmxvY2snXG4gICAgfSxcbiAgICByZW5kZXI6IChwcm9wcykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiB7Li4ucHJvcHMuYXR0cmlidXRlc30gc3R5bGU9e3sgcG9zaXRpb246ICdyZWxhdGl2ZScgfX0+XG4gICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICAgIHtwbGFjZWhvbGRlclxuICAgICAgICAgICAgPyA8UGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3BsYWNlaG9sZGVyQ2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgIG5vZGU9e3Byb3BzLm5vZGV9XG4gICAgICAgICAgICAgICAgcGFyZW50PXtwcm9wcy5zdGF0ZS5kb2N1bWVudH1cbiAgICAgICAgICAgICAgICBzdGF0ZT17cHJvcHMuc3RhdGV9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3BsYWNlaG9sZGVyU3R5bGV9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgIDwvUGxhY2Vob2xkZXI+XG4gICAgICAgICAgICA6IG51bGx9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgc2NoZW1hIHJ1bGUgdG8gcmVuZGVyIGlubGluZSBub2Rlcy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgY29uc3QgSU5MSU5FX1JFTkRFUl9SVUxFID0ge1xuICAgIG1hdGNoOiAobm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUua2luZCA9PSAnaW5saW5lJ1xuICAgIH0sXG4gICAgcmVuZGVyOiAocHJvcHMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxzcGFuIHsuLi5wcm9wcy5hdHRyaWJ1dGVzfSBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9fT5cbiAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGRlZmF1bHQgcmVuZGVyaW5nIHJ1bGVzIHRvIHRoZSBzY2hlbWEuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuXG4gIGNvbnN0IHNjaGVtYSA9IHtcbiAgICBydWxlczogW1xuICAgICAgQkxPQ0tfUkVOREVSX1JVTEUsXG4gICAgICBJTkxJTkVfUkVOREVSX1JVTEVcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb3JlIHBsdWdpbi5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG5cbiAgcmV0dXJuIHtcbiAgICBvbkJlZm9yZUNoYW5nZSxcbiAgICBvbkJlZm9yZUlucHV0LFxuICAgIG9uQmx1cixcbiAgICBvbkNvcHksXG4gICAgb25DdXQsXG4gICAgb25Ecm9wLFxuICAgIG9uS2V5RG93bixcbiAgICBvblBhc3RlLFxuICAgIG9uU2VsZWN0LFxuICAgIHJlbmRlcixcbiAgICBzY2hlbWEsXG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBQbHVnaW5cbiJdfQ==