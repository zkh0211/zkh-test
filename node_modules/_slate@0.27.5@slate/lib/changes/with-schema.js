'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _immutable = require('immutable');

/**
 * Changes.
 *
 * @type {Object}
 */

var Changes = {};

/**
 * Normalize the state with its schema.
 *
 * @param {Change} change
 */

Changes.normalize = function (change) {
  change.normalizeDocument();
};

/**
 * Normalize the document with the state's schema.
 *
 * @param {Change} change
 */

Changes.normalizeDocument = function (change) {
  var state = change.state;
  var document = state.document;

  change.normalizeNodeByKey(document.key);
};

/**
 * Normalize a `node` and its children with the state's schema.
 *
 * @param {Change} change
 * @param {Node|String} key
 */

Changes.normalizeNodeByKey = function (change, key) {
  var state = change.state;
  var document = state.document,
      schema = state.schema;

  var node = document.assertNode(key);
  normalizeNodeAndChildren(change, node, schema);
};

/**
 * Normalize a `node` and its children with a `schema`.
 *
 * @param {Change} change
 * @param {Node} node
 * @param {Schema} schema
 */

function normalizeNodeAndChildren(change, node, schema) {
  if (node.kind == 'text') {
    normalizeNode(change, node, schema);
    return;
  }

  // We can't just loop the children and normalize them, because in the process
  // of normalizing one child, we might end up creating another. Instead, we
  // have to normalize one at a time, and check for new children along the way.
  // PERF: use a mutable array here instead of an immutable stack.
  var keys = node.nodes.toArray().map(function (n) {
    return n.key;
  });

  // While there is still a child key that hasn't been normalized yet...

  var _loop = function _loop() {
    var ops = change.operations.length;
    var key = void 0;

    // PERF: use a mutable set here since we'll be add to it a lot.
    var set = new _immutable.Set().asMutable();

    // Unwind the stack, normalizing every child and adding it to the set.
    while (key = keys[0]) {
      var child = node.getChild(key);
      normalizeNodeAndChildren(change, child, schema);
      set.add(key);
      keys.shift();
    }

    // Turn the set immutable to be able to compare against it.
    set = set.asImmutable();

    // PERF: Only re-find the node and re-normalize any new children if
    // operations occured that might have changed it.
    if (change.operations.length != ops) {
      node = refindNode(change, node);

      // Add any new children back onto the stack.
      node.nodes.forEach(function (n) {
        if (set.has(n.key)) return;
        keys.unshift(n.key);
      });
    }
  };

  while (keys.length) {
    _loop();
  }

  // Normalize the node itself if it still exists.
  if (node) {
    normalizeNode(change, node, schema);
  }
}

/**
 * Re-find a reference to a node that may have been modified or removed
 * entirely by a change.
 *
 * @param {Change} change
 * @param {Node} node
 * @return {Node}
 */

function refindNode(change, node) {
  var state = change.state;
  var document = state.document;

  return node.kind == 'document' ? document : document.getDescendant(node.key);
}

/**
 * Normalize a `node` with a `schema`, but not its children.
 *
 * @param {Change} change
 * @param {Node} node
 * @param {Schema} schema
 */

function normalizeNode(change, node, schema) {
  var max = schema.stack.plugins.length + 1;
  var iterations = 0;

  function iterate(c, n) {
    var normalize = n.validate(schema);
    if (!normalize) return;

    // Run the `normalize` function to fix the node.
    normalize(c);

    // Re-find the node reference, in case it was updated. If the node no longer
    // exists, we're done for this branch.
    n = refindNode(c, n);
    if (!n) return;

    // Increment the iterations counter, and check to make sure that we haven't
    // exceeded the max. Without this check, it's easy for the `validate` or
    // `normalize` function of a schema rule to be written incorrectly and for
    // an infinite invalid loop to occur.
    iterations++;

    if (iterations > max) {
      throw new Error('A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.');
    }

    // Otherwise, iterate again.
    iterate(c, n);
  }

  iterate(change, node);
}

/**
 * Export.
 *
 * @type {Object}
 */

exports.default = Changes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGFuZ2VzL3dpdGgtc2NoZW1hLmpzIl0sIm5hbWVzIjpbIkNoYW5nZXMiLCJub3JtYWxpemUiLCJjaGFuZ2UiLCJub3JtYWxpemVEb2N1bWVudCIsInN0YXRlIiwiZG9jdW1lbnQiLCJub3JtYWxpemVOb2RlQnlLZXkiLCJrZXkiLCJzY2hlbWEiLCJub2RlIiwiYXNzZXJ0Tm9kZSIsIm5vcm1hbGl6ZU5vZGVBbmRDaGlsZHJlbiIsImtpbmQiLCJub3JtYWxpemVOb2RlIiwia2V5cyIsIm5vZGVzIiwidG9BcnJheSIsIm1hcCIsIm4iLCJvcHMiLCJvcGVyYXRpb25zIiwibGVuZ3RoIiwic2V0IiwiYXNNdXRhYmxlIiwiY2hpbGQiLCJnZXRDaGlsZCIsImFkZCIsInNoaWZ0IiwiYXNJbW11dGFibGUiLCJyZWZpbmROb2RlIiwiZm9yRWFjaCIsImhhcyIsInVuc2hpZnQiLCJnZXREZXNjZW5kYW50IiwibWF4Iiwic3RhY2siLCJwbHVnaW5zIiwiaXRlcmF0aW9ucyIsIml0ZXJhdGUiLCJjIiwidmFsaWRhdGUiLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7O0FBRUE7Ozs7OztBQU1BLElBQU1BLFVBQVUsRUFBaEI7O0FBRUE7Ozs7OztBQU1BQSxRQUFRQyxTQUFSLEdBQW9CLFVBQUNDLE1BQUQsRUFBWTtBQUM5QkEsU0FBT0MsaUJBQVA7QUFDRCxDQUZEOztBQUlBOzs7Ozs7QUFNQUgsUUFBUUcsaUJBQVIsR0FBNEIsVUFBQ0QsTUFBRCxFQUFZO0FBQUEsTUFDOUJFLEtBRDhCLEdBQ3BCRixNQURvQixDQUM5QkUsS0FEOEI7QUFBQSxNQUU5QkMsUUFGOEIsR0FFakJELEtBRmlCLENBRTlCQyxRQUY4Qjs7QUFHdENILFNBQU9JLGtCQUFQLENBQTBCRCxTQUFTRSxHQUFuQztBQUNELENBSkQ7O0FBTUE7Ozs7Ozs7QUFPQVAsUUFBUU0sa0JBQVIsR0FBNkIsVUFBQ0osTUFBRCxFQUFTSyxHQUFULEVBQWlCO0FBQUEsTUFDcENILEtBRG9DLEdBQzFCRixNQUQwQixDQUNwQ0UsS0FEb0M7QUFBQSxNQUVwQ0MsUUFGb0MsR0FFZkQsS0FGZSxDQUVwQ0MsUUFGb0M7QUFBQSxNQUUxQkcsTUFGMEIsR0FFZkosS0FGZSxDQUUxQkksTUFGMEI7O0FBRzVDLE1BQU1DLE9BQU9KLFNBQVNLLFVBQVQsQ0FBb0JILEdBQXBCLENBQWI7QUFDQUksMkJBQXlCVCxNQUF6QixFQUFpQ08sSUFBakMsRUFBdUNELE1BQXZDO0FBQ0QsQ0FMRDs7QUFPQTs7Ozs7Ozs7QUFRQSxTQUFTRyx3QkFBVCxDQUFrQ1QsTUFBbEMsRUFBMENPLElBQTFDLEVBQWdERCxNQUFoRCxFQUF3RDtBQUN0RCxNQUFJQyxLQUFLRyxJQUFMLElBQWEsTUFBakIsRUFBeUI7QUFDdkJDLGtCQUFjWCxNQUFkLEVBQXNCTyxJQUF0QixFQUE0QkQsTUFBNUI7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTU0sT0FBT0wsS0FBS00sS0FBTCxDQUFXQyxPQUFYLEdBQXFCQyxHQUFyQixDQUF5QjtBQUFBLFdBQUtDLEVBQUVYLEdBQVA7QUFBQSxHQUF6QixDQUFiOztBQUVBOztBQVpzRDtBQWNwRCxRQUFNWSxNQUFNakIsT0FBT2tCLFVBQVAsQ0FBa0JDLE1BQTlCO0FBQ0EsUUFBSWQsWUFBSjs7QUFFQTtBQUNBLFFBQUllLE1BQU0scUJBQVVDLFNBQVYsRUFBVjs7QUFFQTtBQUNBLFdBQU9oQixNQUFNTyxLQUFLLENBQUwsQ0FBYixFQUFzQjtBQUNwQixVQUFNVSxRQUFRZixLQUFLZ0IsUUFBTCxDQUFjbEIsR0FBZCxDQUFkO0FBQ0FJLCtCQUF5QlQsTUFBekIsRUFBaUNzQixLQUFqQyxFQUF3Q2hCLE1BQXhDO0FBQ0FjLFVBQUlJLEdBQUosQ0FBUW5CLEdBQVI7QUFDQU8sV0FBS2EsS0FBTDtBQUNEOztBQUVEO0FBQ0FMLFVBQU1BLElBQUlNLFdBQUosRUFBTjs7QUFFQTtBQUNBO0FBQ0EsUUFBSTFCLE9BQU9rQixVQUFQLENBQWtCQyxNQUFsQixJQUE0QkYsR0FBaEMsRUFBcUM7QUFDbkNWLGFBQU9vQixXQUFXM0IsTUFBWCxFQUFtQk8sSUFBbkIsQ0FBUDs7QUFFQTtBQUNBQSxXQUFLTSxLQUFMLENBQVdlLE9BQVgsQ0FBbUIsVUFBQ1osQ0FBRCxFQUFPO0FBQ3hCLFlBQUlJLElBQUlTLEdBQUosQ0FBUWIsRUFBRVgsR0FBVixDQUFKLEVBQW9CO0FBQ3BCTyxhQUFLa0IsT0FBTCxDQUFhZCxFQUFFWCxHQUFmO0FBQ0QsT0FIRDtBQUlEO0FBekNtRDs7QUFhdEQsU0FBT08sS0FBS08sTUFBWixFQUFvQjtBQUFBO0FBNkJuQjs7QUFFRDtBQUNBLE1BQUlaLElBQUosRUFBVTtBQUNSSSxrQkFBY1gsTUFBZCxFQUFzQk8sSUFBdEIsRUFBNEJELE1BQTVCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU3FCLFVBQVQsQ0FBb0IzQixNQUFwQixFQUE0Qk8sSUFBNUIsRUFBa0M7QUFBQSxNQUN4QkwsS0FEd0IsR0FDZEYsTUFEYyxDQUN4QkUsS0FEd0I7QUFBQSxNQUV4QkMsUUFGd0IsR0FFWEQsS0FGVyxDQUV4QkMsUUFGd0I7O0FBR2hDLFNBQU9JLEtBQUtHLElBQUwsSUFBYSxVQUFiLEdBQ0hQLFFBREcsR0FFSEEsU0FBUzRCLGFBQVQsQ0FBdUJ4QixLQUFLRixHQUE1QixDQUZKO0FBR0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU00sYUFBVCxDQUF1QlgsTUFBdkIsRUFBK0JPLElBQS9CLEVBQXFDRCxNQUFyQyxFQUE2QztBQUMzQyxNQUFNMEIsTUFBTTFCLE9BQU8yQixLQUFQLENBQWFDLE9BQWIsQ0FBcUJmLE1BQXJCLEdBQThCLENBQTFDO0FBQ0EsTUFBSWdCLGFBQWEsQ0FBakI7O0FBRUEsV0FBU0MsT0FBVCxDQUFpQkMsQ0FBakIsRUFBb0JyQixDQUFwQixFQUF1QjtBQUNyQixRQUFNakIsWUFBWWlCLEVBQUVzQixRQUFGLENBQVdoQyxNQUFYLENBQWxCO0FBQ0EsUUFBSSxDQUFDUCxTQUFMLEVBQWdCOztBQUVoQjtBQUNBQSxjQUFVc0MsQ0FBVjs7QUFFQTtBQUNBO0FBQ0FyQixRQUFJVyxXQUFXVSxDQUFYLEVBQWNyQixDQUFkLENBQUo7QUFDQSxRQUFJLENBQUNBLENBQUwsRUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBbUI7O0FBRUEsUUFBSUEsYUFBYUgsR0FBakIsRUFBc0I7QUFDcEIsWUFBTSxJQUFJTyxLQUFKLENBQVUsME1BQVYsQ0FBTjtBQUNEOztBQUVEO0FBQ0FILFlBQVFDLENBQVIsRUFBV3JCLENBQVg7QUFDRDs7QUFFRG9CLFVBQVFwQyxNQUFSLEVBQWdCTyxJQUFoQjtBQUNEOztBQUVEOzs7Ozs7a0JBTWVULE8iLCJmaWxlIjoid2l0aC1zY2hlbWEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFNldCB9IGZyb20gJ2ltbXV0YWJsZSdcblxuLyoqXG4gKiBDaGFuZ2VzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuY29uc3QgQ2hhbmdlcyA9IHt9XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBzdGF0ZSB3aXRoIGl0cyBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICovXG5cbkNoYW5nZXMubm9ybWFsaXplID0gKGNoYW5nZSkgPT4ge1xuICBjaGFuZ2Uubm9ybWFsaXplRG9jdW1lbnQoKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgc3RhdGUncyBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICovXG5cbkNoYW5nZXMubm9ybWFsaXplRG9jdW1lbnQgPSAoY2hhbmdlKSA9PiB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGNoYW5nZVxuICBjb25zdCB7IGRvY3VtZW50IH0gPSBzdGF0ZVxuICBjaGFuZ2Uubm9ybWFsaXplTm9kZUJ5S2V5KGRvY3VtZW50LmtleSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBgbm9kZWAgYW5kIGl0cyBjaGlsZHJlbiB3aXRoIHRoZSBzdGF0ZSdzIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gKiBAcGFyYW0ge05vZGV8U3RyaW5nfSBrZXlcbiAqL1xuXG5DaGFuZ2VzLm5vcm1hbGl6ZU5vZGVCeUtleSA9IChjaGFuZ2UsIGtleSkgPT4ge1xuICBjb25zdCB7IHN0YXRlIH0gPSBjaGFuZ2VcbiAgY29uc3QgeyBkb2N1bWVudCwgc2NoZW1hIH0gPSBzdGF0ZVxuICBjb25zdCBub2RlID0gZG9jdW1lbnQuYXNzZXJ0Tm9kZShrZXkpXG4gIG5vcm1hbGl6ZU5vZGVBbmRDaGlsZHJlbihjaGFuZ2UsIG5vZGUsIHNjaGVtYSlcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSBgbm9kZWAgYW5kIGl0cyBjaGlsZHJlbiB3aXRoIGEgYHNjaGVtYWAuXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplTm9kZUFuZENoaWxkcmVuKGNoYW5nZSwgbm9kZSwgc2NoZW1hKSB7XG4gIGlmIChub2RlLmtpbmQgPT0gJ3RleHQnKSB7XG4gICAgbm9ybWFsaXplTm9kZShjaGFuZ2UsIG5vZGUsIHNjaGVtYSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFdlIGNhbid0IGp1c3QgbG9vcCB0aGUgY2hpbGRyZW4gYW5kIG5vcm1hbGl6ZSB0aGVtLCBiZWNhdXNlIGluIHRoZSBwcm9jZXNzXG4gIC8vIG9mIG5vcm1hbGl6aW5nIG9uZSBjaGlsZCwgd2UgbWlnaHQgZW5kIHVwIGNyZWF0aW5nIGFub3RoZXIuIEluc3RlYWQsIHdlXG4gIC8vIGhhdmUgdG8gbm9ybWFsaXplIG9uZSBhdCBhIHRpbWUsIGFuZCBjaGVjayBmb3IgbmV3IGNoaWxkcmVuIGFsb25nIHRoZSB3YXkuXG4gIC8vIFBFUkY6IHVzZSBhIG11dGFibGUgYXJyYXkgaGVyZSBpbnN0ZWFkIG9mIGFuIGltbXV0YWJsZSBzdGFjay5cbiAgY29uc3Qga2V5cyA9IG5vZGUubm9kZXMudG9BcnJheSgpLm1hcChuID0+IG4ua2V5KVxuXG4gIC8vIFdoaWxlIHRoZXJlIGlzIHN0aWxsIGEgY2hpbGQga2V5IHRoYXQgaGFzbid0IGJlZW4gbm9ybWFsaXplZCB5ZXQuLi5cbiAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgb3BzID0gY2hhbmdlLm9wZXJhdGlvbnMubGVuZ3RoXG4gICAgbGV0IGtleVxuXG4gICAgLy8gUEVSRjogdXNlIGEgbXV0YWJsZSBzZXQgaGVyZSBzaW5jZSB3ZSdsbCBiZSBhZGQgdG8gaXQgYSBsb3QuXG4gICAgbGV0IHNldCA9IG5ldyBTZXQoKS5hc011dGFibGUoKVxuXG4gICAgLy8gVW53aW5kIHRoZSBzdGFjaywgbm9ybWFsaXppbmcgZXZlcnkgY2hpbGQgYW5kIGFkZGluZyBpdCB0byB0aGUgc2V0LlxuICAgIHdoaWxlIChrZXkgPSBrZXlzWzBdKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuZ2V0Q2hpbGQoa2V5KVxuICAgICAgbm9ybWFsaXplTm9kZUFuZENoaWxkcmVuKGNoYW5nZSwgY2hpbGQsIHNjaGVtYSlcbiAgICAgIHNldC5hZGQoa2V5KVxuICAgICAga2V5cy5zaGlmdCgpXG4gICAgfVxuXG4gICAgLy8gVHVybiB0aGUgc2V0IGltbXV0YWJsZSB0byBiZSBhYmxlIHRvIGNvbXBhcmUgYWdhaW5zdCBpdC5cbiAgICBzZXQgPSBzZXQuYXNJbW11dGFibGUoKVxuXG4gICAgLy8gUEVSRjogT25seSByZS1maW5kIHRoZSBub2RlIGFuZCByZS1ub3JtYWxpemUgYW55IG5ldyBjaGlsZHJlbiBpZlxuICAgIC8vIG9wZXJhdGlvbnMgb2NjdXJlZCB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCBpdC5cbiAgICBpZiAoY2hhbmdlLm9wZXJhdGlvbnMubGVuZ3RoICE9IG9wcykge1xuICAgICAgbm9kZSA9IHJlZmluZE5vZGUoY2hhbmdlLCBub2RlKVxuXG4gICAgICAvLyBBZGQgYW55IG5ldyBjaGlsZHJlbiBiYWNrIG9udG8gdGhlIHN0YWNrLlxuICAgICAgbm9kZS5ub2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGlmIChzZXQuaGFzKG4ua2V5KSkgcmV0dXJuXG4gICAgICAgIGtleXMudW5zaGlmdChuLmtleSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBub2RlIGl0c2VsZiBpZiBpdCBzdGlsbCBleGlzdHMuXG4gIGlmIChub2RlKSB7XG4gICAgbm9ybWFsaXplTm9kZShjaGFuZ2UsIG5vZGUsIHNjaGVtYSlcbiAgfVxufVxuXG4vKipcbiAqIFJlLWZpbmQgYSByZWZlcmVuY2UgdG8gYSBub2RlIHRoYXQgbWF5IGhhdmUgYmVlbiBtb2RpZmllZCBvciByZW1vdmVkXG4gKiBlbnRpcmVseSBieSBhIGNoYW5nZS5cbiAqXG4gKiBAcGFyYW0ge0NoYW5nZX0gY2hhbmdlXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cblxuZnVuY3Rpb24gcmVmaW5kTm9kZShjaGFuZ2UsIG5vZGUpIHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gY2hhbmdlXG4gIGNvbnN0IHsgZG9jdW1lbnQgfSA9IHN0YXRlXG4gIHJldHVybiBub2RlLmtpbmQgPT0gJ2RvY3VtZW50J1xuICAgID8gZG9jdW1lbnRcbiAgICA6IGRvY3VtZW50LmdldERlc2NlbmRhbnQobm9kZS5rZXkpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgYG5vZGVgIHdpdGggYSBgc2NoZW1hYCwgYnV0IG5vdCBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtDaGFuZ2V9IGNoYW5nZVxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplTm9kZShjaGFuZ2UsIG5vZGUsIHNjaGVtYSkge1xuICBjb25zdCBtYXggPSBzY2hlbWEuc3RhY2sucGx1Z2lucy5sZW5ndGggKyAxXG4gIGxldCBpdGVyYXRpb25zID0gMFxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoYywgbikge1xuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IG4udmFsaWRhdGUoc2NoZW1hKVxuICAgIGlmICghbm9ybWFsaXplKSByZXR1cm5cblxuICAgIC8vIFJ1biB0aGUgYG5vcm1hbGl6ZWAgZnVuY3Rpb24gdG8gZml4IHRoZSBub2RlLlxuICAgIG5vcm1hbGl6ZShjKVxuXG4gICAgLy8gUmUtZmluZCB0aGUgbm9kZSByZWZlcmVuY2UsIGluIGNhc2UgaXQgd2FzIHVwZGF0ZWQuIElmIHRoZSBub2RlIG5vIGxvbmdlclxuICAgIC8vIGV4aXN0cywgd2UncmUgZG9uZSBmb3IgdGhpcyBicmFuY2guXG4gICAgbiA9IHJlZmluZE5vZGUoYywgbilcbiAgICBpZiAoIW4pIHJldHVyblxuXG4gICAgLy8gSW5jcmVtZW50IHRoZSBpdGVyYXRpb25zIGNvdW50ZXIsIGFuZCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCB3ZSBoYXZlbid0XG4gICAgLy8gZXhjZWVkZWQgdGhlIG1heC4gV2l0aG91dCB0aGlzIGNoZWNrLCBpdCdzIGVhc3kgZm9yIHRoZSBgdmFsaWRhdGVgIG9yXG4gICAgLy8gYG5vcm1hbGl6ZWAgZnVuY3Rpb24gb2YgYSBzY2hlbWEgcnVsZSB0byBiZSB3cml0dGVuIGluY29ycmVjdGx5IGFuZCBmb3JcbiAgICAvLyBhbiBpbmZpbml0ZSBpbnZhbGlkIGxvb3AgdG8gb2NjdXIuXG4gICAgaXRlcmF0aW9ucysrXG5cbiAgICBpZiAoaXRlcmF0aW9ucyA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNjaGVtYSBydWxlIGNvdWxkIG5vdCBiZSB2YWxpZGF0ZWQgYWZ0ZXIgc3VmZmljaWVudCBpdGVyYXRpb25zLiBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGEgYHJ1bGUudmFsaWRhdGVgIG9yIGBydWxlLm5vcm1hbGl6ZWAgZnVuY3Rpb24gb2YgYSBzY2hlbWEgYmVpbmcgaW5jb3JyZWN0bHkgd3JpdHRlbiwgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wLicpXG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIGFnYWluLlxuICAgIGl0ZXJhdGUoYywgbilcbiAgfVxuXG4gIGl0ZXJhdGUoY2hhbmdlLCBub2RlKVxufVxuXG4vKipcbiAqIEV4cG9ydC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IENoYW5nZXNcbiJdfQ==